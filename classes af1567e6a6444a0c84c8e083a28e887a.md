# classes

Created: April 13, 2022 11:28 AM
Last Edited Time: April 13, 2022 4:24 PM

### 9 Classes

1 A class is a type. Its name becomes a *class-name* (9.1) within its scope.

*class-name:
    identifier
    simple-template-id*

*Class-specifiers* and *elaborated-type-specifiers* (7.1.6.3) are used to make class-names. An object of a class consists of a (possibly empty) sequence of members and base class objects.

*class-specifier:
    class-head { member-specificationopt }
class-head:
    class-key attribute-specifier-seqopt class-head-name class-virt-specifieropt base-clauseopt
    class-key attribute-specifier-seqopt base-clauseopt
class-head-name:
    nested-name-specifieropt class-name
class-virt-specifier:
    final
class-key:
    class
    struct
    union*

A *class-specifier* whose *class-head* omits the *class-head-name* defines an unnamed class. [ Note: An unnamed class thus can’t be **final**. — end note ]

2 A *class-name* is inserted into the scope in which it is declared immediately after the *class-name* is seen. The *class-name* is also inserted into the scope of the class itself; this is known as the *injected-class-name*. For purposes of access checking, the injected-class-name is treated as if it were a public member name.

> [3.3.2/3] The point of declaration for a class or class template first declared by a class-specifier is immediately after the identifier or simple-template-id (if any) in its class-head (Clause 9).
[3.3.2/7] The point of declaration for an injected-class-name (Clause 9) is immediately following the opening brace of the class definition.
> 
> 
> [14.2/6] A *simple-template-id* that names a class template specialization is a *class-name*(Clause 9).
> 

```cpp
template <typename T>
struct Base
{};

struct S : Base<S>      //ok, 在`S`出现之后它就被引入到当前声明的作用域及其类作用域.
{
  typedef S self_type;  //ok.
};

static S s; //ok, S已经被引入类作用域.

template<typename T>
struct Array {};
template <>
struct Array<int>
	: Base< Array<int> > //ok, Array<int> 是一个 simple-template-id, 所以也是一个类名, 因此也符合上面的定义.
{

};

class C;
static C* p;	 //ok
class C
{

};
```

A *class-specifier* is commonly referred to as a class definition. A class is considered defined after the closing brace of its *class-specifier* has been seen even though its member functions are in general not yet defined. The optional *attribute-specifier-seq* appertains to the class; the attributes in the *attribute-specifier-seq* are thereafter considered attributes of the class whenever it is named.

对应 [9.2/2]

3 If a class is marked with the *class-virt-specifier* **final** and it appears as a *base-type-specifier* in a *base-clause* (Clause 10), the program is ill-formed.

```cpp
class B
{

};

class D : final B //error
{

};
```

4 Complete objects and member subobjects of class type shall have nonzero size.107 [ Note: Class objects can be assigned, passed as arguments to functions, and returned by functions (except objects of classes for which copying or moving has been restricted; see 12.8). Other plausible operators, such as equality comparison, can be defined by the user; see 13.5. — end note ]

> Base class subobjects are not so constrained.
> 

5 A *union* is a class defined with the class-key **union**; it holds only one data member at a time (9.5). [ Note: Aggregates of class type are described in 8.5.1. — end note ]

6 A trivially copyable class is a class that:

— has no non-trivial copy constructors (12.8),

— has no non-trivial move constructors (12.8),

— has no non-trivial copy assignment operators (13.5.3, 12.8),

— has no non-trivial move assignment operators (13.5.3, 12.8), and

— has a trivial destructor (12.4).

A *trivial class* is a class that has a trivial default constructor (12.1) and is trivially copyable.
[Note: In particular, a trivially copyable or trivial class does not have virtual functions or virtual base classes. — end note ]

7 A standard-layout class is a class that:

— has no non-static data members of type non-standard-layout class (or array of such types) or reference,

— has no virtual functions (10.3) and no virtual base classes (10.1),

— has the same access control (Clause 11) for all non-static data members,

— has no non-standard-layout base classes,

— either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base classes with non-static data members, and

— has no base classes of the same type as the first non-static data member.108

8 A *standard-layout struct* is a standard-layout class defined with the class-key **struct** or the class-key **class**.
A *standard-layout union* is a standard-layout class defined with the class-key **union**.

10 A *POD struct*<sup>109</sup> is a non-union class that is both a trivial class and a standard-layout class, and has no non-static data members of type non-POD struct, non-POD union (or array of such types). Similarly, a POD union is a union that is both a trivial class and a standard layout class, and has no non-static data members of type non-POD struct, non-POD union (or array of such types). A POD class is a class that is either a POD struct or a POD union.

> The acronym POD stands for “plain old data”.
> 

```cpp
struct N { // neither trivial nor standard-layout int i;
  int j;
  virtual ~N();
};

struct T { // trivial but not standard-layout int i;
private:
  int j;
};

struct SL { // standard-layout but not trivial int i;
  int j;
  ~SL();
};

struct POD { // both trivial and standard-layout
  int i;
  int j;
};

```

11 If a *class-head-name* contains a *nested-name-specifier*, the *class-specifier* shall refer to a class that was previously declared directly in the class or namespace to which the *nested-name-specifier* refers, or in an element of the inline namespace set (7.3.1) of that namespace (i.e., not merely inherited or introduced by a using-declaration), and the *class-specifier* shall appear in a namespace enclosing the previous declaration. In such cases, the *nested-name-specifier* of the *class-head-name* of the definition shall not begin with a *decltype-specifier* .

```cpp
class X
{
    class Inner;
};

class X::Inner {  //ok

};

namespace N
{
    class Inner;
}

class N::Inner  //ok
{

};

namespace B
{
    class BInner;
}
namespace E
{
    inline namespace I
    {
        class Inner;
    };
    using namespace B;
}
class E::Inner  //ok
{

};

class E::BInner //ok
{

};

namespace S
{
	class Inner;
};

namespace M
{
	class S::Inner //error [... and the *class-specifier* shall appear in a namespace enclosing the previous declaration.]
	{

	};
};
```

### 9.1 Class names

1 A class definition introduces a new type.

```cpp
struct X { int a; };
struct Y { int a; };
X a1;
Y a2;
int a3;
```

declares three variables of three different types. This implies that

```cpp
a1 = a2; // error: Y assigned to X
a1 = a3; // error: int assigned to X
```

are type mismatches, and that

```cpp
int f(X);
int f(Y);
```

declare an overloaded (Clause 13) function f() and not simply a single function f() twice. For the same reason,

```cpp
struct S { int a; };
struct S { int a; }; // error, double definition
```

is ill-formed because it defines S twice.

2 A class declaration introduces the class name into the scope where it is declared and hides any class, variable, function, or other declaration of that name in an enclosing scope (3.3). If a class name is declared in a scope where a variable, function, or enumerator of the same name is also declared, then when both declarations are in scope, the class can be referred to only using an *elaborated-type-specifier* (3.4.4).

> [3.3.10/2] A class name (9.1) or enumeration name (7.2) can be hidden by the name of a variable, data member, function, or enumerator declared in the same scope. If a class or enumeration name and a variable, data member, function, or enumerator are declared in the same scope (in any order) with the same name, the class or enumeration name is hidden wherever the variable, data member, function, or enumerator name is visible.
[3.4.4/1] An elaborated-type-specifier (7.1.6.3) may be used to refer to a previously declared class-name or enum-name even though the name has been hidden by a non-type declaration (3.3.10).
> 

```cpp
namespace X {
    class v //hidden by variable v;
    {

    };
    int v;
    bool fv() {
    	return std::is_same<decltype(v), int>::value;	//true;
    }

    class e {	//hidden by enum e;
    	char b[16];
    };
    enum {
    	e
    };
    bool fe() {
    	return sizeof(e) == sizeof(class e);	//false
    }

    class f {};	//hidden by function f;
    void f(){};
    bool g() {
    	return std::is_same<decltype(f), void()>::value;	//true;
    };

    struct C {
    	int c;
    	class c {	//hidden by data member c;
    		char b[16];
    	};

    	bool fc() {
    		return sizeof(c) == sizeof(class c);	//false
    	}
    };
};

int main() {
    std::boolalpha(std::cout);
	std::cout << std::is_same<decltype(X::v), int>::value << std::endl;      //true
	std::cout << (sizeof(X::e) == sizeof(class X::e)) << std::endl;          //false
	std::cout << std::is_same<decltype(X::f), void()>::value << std::endl;   //true
	std::cout << (sizeof(X::C::c) == sizeof(class X::C::c)) << std::endl;    //false
}

```

```cpp
struct stat {
// ...
};
stat gstat; // use plain stat to
            // define variable

int stat(struct stat*); // redeclare stat as function
void f() {
  struct stat* ps;  // struct prefix needed
                    // to name struct stat
  stat(ps);         // call stat()
}
```

A *declaration* consisting solely(仅仅) of *`class-key identifier;`* is either a redeclaration of the name in the current scope or a forward declaration of the identifier as a class name. It introduces the class name into the current scope.

```cpp
struct s { int a; };
void g() {
  struct s;              // hide global struct s
                         // with a block-scope declaration
  s* p;                  // refer to local struct s
  struct s { char* p; }; // define local struct s
  struct s;              // redeclaration, has no effect
}
```

[ Note: Such declarations allow definition of classes that refer to each other(互相引用).

```cpp
class Vector;
class Matrix {
  // ...
  friend Vector operator*(const Matrix&, const Vector&);
};
class Vector {
  // ...
  friend Vector operator*(const Matrix&, const Vector&);
};
```

Declaration of friends is described in 11.3, operator functions in 13.5. — end note ]

3 [ Note: An *elaborated-type-specifier* (7.1.6.3) can also be used as a *type-specifier* as part of a declaration. It differs from a class declaration in that if a class of the elaborated name is in scope the elaborated name will refer to it. —end note]

elaborated-type-specifier 可以被作为 type-specifier 用在声明中, 这种情况下`elaborated name`将引用之前声明过的类名.
这种用法与class declaration不同是指类声明会引入名字到作用域, 但是这种用法并不会引入名字到作用域.

```cpp
struct s { int a; };
void g(int s) {
  struct s* p = new struct s; // global s
  p->a = s;                   // parameter s
}
```

4 [Note: The declaration of a class name takes effect(生效) immediately after the *identifier* is seen in the class definition or *elaborated-type-specifier*. For example,

***class A * A;***

first specifies **A** to be the name of a class and then redefines it as the name of a pointer to an object of that class. This means that the elaborated form **class A** must be used to refer to the class. Such artistry with names can be confusing and is best avoided. — end note ]

对应[9/2], [3.3.2/3].

```cpp
class A;
A* A;       //class A * A; 等价于这两句的行为.

A* p;       //error: class A被变量A隐藏. [9.1/2]
struct A* s;  //ok [9.1/2], [3.4.4/1]
```

5 A *typedef-name* (7.1.3) that names a class type, or a cv-qualified version thereof, is also a *class-name*. If a *typedef-name* that names a cv-qualified class type is used where a *class-name* is required, the cv-qualifiers are ignored. A *typedef-name* shall not be used as the *identifier* in a *class-head*.

[3.3.2/6]
The point of declaration of a class first declared in an *elaborated-type-specifier* is as follows:
— for a declaration of the form

 ***class-key attribute-specifier-seqopt identifier ;***

the *identifier* is declared to be a *class-name* in the scope that contains the declaration, otherwise
— for an *elaborated-type-specifier* of the form

 ***class-key identifier***

if the *elaborated-type-specifier* is used in the *decl-specifier-seq* or *parameter-declaration-clause* of a function defined in namespace scope, the *identifier* is declared as a *class-name* in the namespace that contains the declaration; otherwise, except as a friend declaration, the identifier is declared in the smallest namespace or block scope that contains the declaration. [ Note: These rules also apply within templates. — end note ] [ Note: Other forms of elaborated-type-specifier do not declare a new name, and therefore must refer to an existing type-name. See 3.4.4 and 7.1.6.3. — end note ]

### 9.2 Class members

*member-specification:
    member-declaration member-specificationopt
    access-specifier : member-specificationopt
member-declaration:
    attribute-specifier-seqopt decl-specifier-seqopt member-declarator-listopt ;
    function-definition ;opt
    using-declaration
    static_assert-declaration template-declaration
    alias-declaration
member-declarator-list:
    member-declarator
    member-declarator-list , member-declarator
member-declarator:
    declarator virt-specifier-seqopt pure-specifieropt
    declarator brace-or-equal-initializeropt
    identifieropt attribute-specifier-seqopt : constant-expression
virt-specifier-seq:
    virt-specifier
    virt-specifier-seq virt-specifier
virt-specifier:
    override
    final
pure-specifier:
    =0*

1 The *member-specification* in a class definition declares the full set of members of the class; no member can be added elsewhere. Members of a class are data members, member functions (9.3), nested types, and enumerators. Data members and member functions are static or non-static; see 9.4. Nested types are classes (9.1, 9.7) and enumerations (7.2) defined in the class, and arbitrary types declared as members by use of a typedef declaration (7.1.3). The enumerators of an unscoped enumeration (7.2) defined in the class are members of the class. Except when used to declare friends (11.3) or to introduce the name of a member of a base class into a derived class (7.3.3), *member-declarations* declare members of the class, and each such *member-declaration* shall declare at least one member name of the class. A member shall not be declared twice in the *member-specification*, except that a nested class or member class template can be declared and then later defined, and except that an enumeration can be introduced with an *opaque-enum-declaration* and later redeclared with an enum-specifier.

2 A class is considered a completely-defined object type (3.9) (or complete type) at the closing } of the class-specifier. Within the class member-specification, the class is regarded as(被认为是) complete within function bodies, default arguments, *exception-specifications*, and *brace-or-equal-initializers* for non-static data members (including such things in nested classes). Otherwise it is regarded as incomplete within its own class *member-specification*.

对应 [9/2], [9.2/10]

```cpp
class X
{
    X x;  //error [3.9/5] Objects shall not be defined to have an incomplete type.
          //      [3.1/5] A program is ill-formed if the definition of any object gives the object an incomplete type (3.9).
          //      [9.2/10] Non-static (9.4) data members shall not have incomplete types.
    X* p; //ok

    void f()
    {
        X x; //ok
    }
};

static X x; //ok.
```

4 A member can be initialized using a constructor; see 12.1. [Note: See Clause 12 for a description of constructors and other special member functions. — end note ]

5 A member can be initialized using a *brace-or-equal-initializer*. (For static data members, see 9.4.2; for non-static data members, see 12.6.2).

6 A member shall not be declared with the **extern** or **register** *storage-class-specifier*. Within a class definition, a member shall not be declared with the *thread_local* *storage-class-specifier* unless also declared **static**.

```cpp
class X
{
    extern register int x;  //error
    thread_local int t;     //error
    static thread_local int st; //ok
};
```

7 The *decl-specifier-seq* may be omitted in constructor, destructor, and conversion function declarations only; when declaring another kind of member the *decl-specifier-seq* shall contain a *type-specifier* that is not a *cv-qualifier*. The *member-declarator-list* can be omitted only after a *class-specifier* or an *enum-specifier* or in a **friend** declaration (11.3). A *pure-specifier* shall be used only in the declaration of a virtual function (10.3).

8 The optional *attribute-specifier-seq* in a *member-declaration* appertains to each of the entities declared by the *member-declarators*; it shall not appear if the optional *member-declarator-list* is omitted.

9 A *virt-specifier-seq* shall contain at most one of each *virt-specifier*. A *virt-specifier-seq* shall appear only in the declaration of a virtual member function (10.3).

10 Non-**static** (9.4) data members shall not have incomplete types. In particular, a class C shall not contain a non-static member of class C, but it can contain a pointer or reference to an object of class C.

对应[9.2/2]

13 [ Example: A simple example of a class definition is

```cpp
struct tnode {
    char tword[20];
    int count;
    tnode *left;
    tnode *right;
};
```

which contains an array of twenty characters, an integer, and two pointers to objects of the same type. Once this definition has been given, the declaration

***tnode s, *sp;***

declares **s** to be a **tnode** and **sp** to be a pointer to a **tnode**. With these declarations, **sp->count** refers to the count member of the object to which **sp** points; **s.left** refers to the **left** subtree pointer of the object **s**; and **s.right->tword[0]** refers to the initial character of the **tword** member of the **right** subtree of **s**. — end example ]

14 Nonstatic data members of a (non-union) class with the same access control (Clause 11) are allocated so that later members have higher addresses within a class object. The order of allocation of non-static data members with different access control is unspecified (11). Implementation alignment requirements might cause two adjacent members not to be allocated immediately after each other; so might requirements for space for managing virtual functions (10.3) and virtual base classes (10.1).

15 If T is the name of a class, then each of the following shall have a name different from T:

— every static data member of class T;

— every member function of class T [ Note: This restriction does not apply to constructors, which do not have names (12.1) — end note ];

— every member of class T that is itself a type;

— every enumerator of every member of class T that is an unscoped enumerated type; and

— every member of every anonymous union that is a member of class T.

16 In addition, if class T has a user-declared constructor (12.1), every non-static data member of class T shall have a name different from T.

17 Two standard-layout struct (Clause 9) types are layout-compatible if they have the same number of non-static data members and corresponding non-static data members (in declaration order) have layout-compatible types (3.9).

18 Two standard-layout union (Clause 9) types are layout-compatible if they have the same number of non- static data members and corresponding non-static data members (in any order) have layout-compatible types (3.9).

19 If a standard-layout union contains two or more standard-layout structs that share a common initial sequence, and if the standard-layout union object currently contains one of these standard-layout structs, it is permitted to inspect the common initial part of any of them. Two standard-layout structs share a common initial sequence if corresponding members have layout-compatible types and either neither member is a bit-field or both are bit-fields with the same width for a sequence of one or more initial members.

20 A pointer to a standard-layout struct object, suitably converted using a **reinterpret_cast**, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. [ Note: There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning, as necessary to achieve appropriate alignment. — end note ]

### 9.3 Member functions

1 Functions declared in the definition of a class, excluding those declared with a friend specifier (11.3), are called member functions of that class. A member function may be declared static in which case it is a static member function of its class (9.4); otherwise it is a non-static member function of its class (9.3.1, 9.3.2).

2 A member function may be defined (8.4) in its class definition, in which case it is an *inline* member function (7.1.2), or it may be defined outside of its class definition if it has already been declared but not defined in its class definition. A member function definition that appears outside of the class definition shall appear in a namespace scope enclosing the class definition. Except for member function definitions that appear outside of a class definition, and except for explicit specializations of member functions of class templates and member function templates (14.7) appearing outside of the class definition, a member function shall not be redeclared.

```cpp
class X
{
    void f();   //error
    void f();

    void g();   //error
    void g()
    {

    };

    void p();   //ok
};

void X::p()
{

}
```

3 An **inline** member function (whether static or non-static) may also be defined outside of its class definition provided either its declaration in the class definition or its definition outside of the class definition declares the function as **inline**. [Note: Member functions of a class in namespace scope have external linkage. Member functions of a local class (9.8) have no linkage. See 3.5. — end note ]

```cpp
class X
{
    inline void f();    //f是内联成员函数.
    void g();           //g是内联成员函数.
};

void X::f()
{

}

inline void X::g()
{

}
```

4 There shall be at most one definition of a non-inline member function in a program; no diagnostic is required. There may be more than one inline member function definition in a program. See 3.2 and 7.1.2.

5 If the definition of a member function is lexically outside its class definition, the member function name shall be qualified by its class name using the :: operator. [Note: A name used in a member function definition (that is, in the *parameter-declaration-clause* including the default arguments (8.3.6) or in the member function body) is looked up as described in 3.4. — end note ]

```cpp
struct X {
    typedef int T;
    static T count;
    void f(T);
};
void X::f(T t = count) { }
```

The member function f of class X is defined in global scope; the notation X::f specifies that the function f is a member of class X and in the scope of class X. In the function definition, the parameter type T refers to the typedef member T declared in class X and the default argument count refers to the static data member count declared in class X. — end example ]

6 A **static** local variable in a member function always refers to the same object, whether or not the member function is **inline**.

暂时还不清楚这个定义的目的, 感觉这应该和内联函数替换有关

7 Previously declared member functions may be mentioned(提及, 提到) in friend declarations.

8 Member functions of a local class shall be defined inline in their class definition, if they are defined at all.

9 [Note: A member function can be declared (but not defined) using a typedef for a function type. The resulting member function has exactly the same type as it would have if the function declarator were provided explicitly, see 8.3.5. For example,

```cpp
typedef void fv(void);
typedef void fvc(void) const;
struct S {
    fv memfunc1;    // equivalent to: void memfunc1(void);
    void memfunc2();
    fvc memfunc3;   // equivalent to: void memfunc3(void) const;
};
fv  S::* pmfv1 = &S::memfunc1;
fv  S::* pmfv2 = &S::memfunc2;
fvc S::* pmfv3 = &S::memfunc3;
```

Also see 14.3. — end note ]

### 9.3.1 Nonstatic member functions

1 A *non-static* member function may be called for an object of its class type, or for an object of a class derived (Clause 10) from its class type, using the class member access syntax (5.2.5, 13.3.1.1). A non-static member function may also be called directly using the function call syntax (5.2.2, 13.3.1.1) from within the body of a member function of its class or of a class derived from its class.

非静态成员函数被调用的几种方式

```cpp
struct X
{
    void f()
    {

    }

    void g()
    {
        f();    //ok
    }
};

struct S : public X
{

};

void q()
{
    X x;
    x.f();  //ok

    S s;
    s.f();  //ok
}
```

2 If a non-static member function of a class X is called for an object that is not of type X, or of a type derived from X, the behavior is undefined.

3 When an *id-expression* (5.1) that is not part of a class member access syntax (5.2.5) and not used to form a pointer to member (5.3.1) is used in a member of class X in a context where **this** can be used (5.1.1), if name lookup (3.4) resolves the name in the id-expression to a non-static non-type member of some class C, and if either the *id-expression* is potentially evaluated or C is X or a base class of X, the *id-expression* is transformed into a class member access expression (5.2.5) using (\*this) (9.3.2) as the *postfix-expression* to the left of the . operator. [Note: If C is not X or a base class of X, the class member access expression is ill-formed. — end note ] Similarly during name lookup, when an unqualified-id (5.1) used in the definition of a member function for class X resolves to a static member, an enumerator or a nested type of class X or of a base class of X, the unqualified-id is transformed into a qualified-id (5.1) in which the *nested-name-specifier* names the class of the member function.

当一个*id-expression*满足:

`not part of a class member access syntax` 指的是这个*id-expression*不是出现在形如`E1.E2`或 `E1->E2`的表达式中,

`not used to form a pointer to member`指的是*id-expression*不是出现在形如`&C::m`的表达式中,
并且这个*id-expression*被用在类X的成员上,
并且出现在一个允许**this**出现的上下文(比如成员函数体内),
如果通过名称查找解析*id-expression*中的名字是某个类C的非静态非类型成员, 
并且如果这个*id-expression*会被潜在求值(`potentially evaluated`)或C是X或是X的基类,
则这个*id-expression*会被翻译成一个类成员访问表达式使用 **this* 作为`.`操作符的前缀表达式.
如果C不是X也不是X的基类, 则最后翻译得到的类成员访问表达式是ill-formed.

```cpp
struct C
{
    int a;
    int b;
};

struct X : public C
{
    int a;

    void f()
    {
        int ca = (*this).C::a;   //ok, 访问C::a , 但不符合`not part of a class member access syntax`, 所以不会被翻译成(*this).(*this).C::a;
        int C::* cp = &C::a; //ok, 访问C::a, 但是不符合`not used to form a pointer to member`, 所以不会被翻译成 &(*this).C::a;
                                // 这可能是因为对类成员取地址得到的并不是其真实地址, 所以实现不会通过这种取地址的方式.

        a+b;    //ok, 在f的函数体内是一个允许this出现的上下文 并且名称查找a发现X::a,查找b发现C::b, 并且C是X的基类,  所以这个表达式(可能)会被翻译成 (*this).a + (*this).b;
        //a+c;    //ill-formed. c不是X或其基类的成员.
    }

    struct Ic
    {

    };

    void g()
    {
        typedef Ic inner_type;      //Ic会被翻译成 C::Ic, 所以表达式变成 typedef C::Ic inner_type;
        s + e;              //s会被翻译成C::s, e会被翻译成C::e, 所以表达式变成 C::s + C::e;
    }

    static const int s = 16;
    enum
    {
        e = 0
    };
};
```

```cpp
struct tnode {
    char tword[20];
    int count;
    tnode *left;
    tnode *right;
    void set(const char*, tnode* l, tnode* r);
};
void tnode::set(const char* w, tnode* l, tnode* r) {
    count = strlen(w)+1;
    if (sizeof(tword)<=count)
       perror("tnode string too long");
    strcpy(tword,w);
    left = l;
    right = r;
}
void f(tnode n1, tnode n2) {
    n1.set("abc",&n2,0);
    n2.set("def",0,0);
}
```

In the body of the member function tnode::set, the member names tword, count, left, and right refer to members of the object for which the function is called. Thus, in the call n1.set("abc",&n2,0), tword refers to n1.tword, and in the call n2.set("def",0,0), it refers to n2.tword. The functions strlen, perror, and strcpy are not members of the class tnode and should be declared elsewhere.110

4 A non-static member function may be declared **const**, **volatile**, or **const volatile**. These cv-qualifiers affect the type of the this pointer (9.3.2). They also affect the function type (8.3.5) of the member function; a member function declared const is a **const** member function, a member function declared volatile is a **volatile** member function and a member function declared **const volatile** is a const volatile member function.

> [8.3.5/6] The return type, the parameter-type-list, the ref-qualifier, and the cv-qualifier-seq, but not the default arguments (8.3.6) or the exception specification (15.4), are part of the function type. [Note: Function types are checked during the assignments and initializations of pointers to functions, references to functions, and pointers to member functions. — end note ]
> 

```cpp
struct X {
    void g() const;
    void h() const volatile;
};

//void(X::* pg)() = &X::g; //error [8.3.5/6]
//void(X::* ph)() = &X::h; //error [8.3.5/6]

void(X::* pg)() const = &X::g;          //ok
void(X::* ph)() const volatile = &X::h; //ok
```

X::g is a **const** member function and X::h is a **const volatile** member function. — end example ]

5 A non-static member function may be declared with a *ref-qualifier* (8.3.5); see 13.3.1.
6 A non-static member function may be declared *virtual* (10.3) or *pure virtual* (10.4).

### 9.3.2 The this pointer

1 In the body of a non-static (9.3) member function, the keyword **this** is a prvalue expression whose value is the address of the object for which the function is called. The type of **this** in a member function of a **class X** is **X****. If the member function is declared **const**, the type of this is **const X****, if the member function is declared **volatile**, the type of this is **volatile X****, and if the member function is declared **const volatile**, the type of this is **const volatile X****.

```cpp
struct X
{
    void f()
    {
        std::cout << std::is_same<decltype(this), X*>::value << std::endl;  //true
    }
    void g() const
    {
        std::cout << std::is_same<decltype(this), const X*>::value << std::endl;    //true
    }
    void h() const volatile
    {
        std::cout << std::is_same<decltype(this), const volatile X*>::value << std::endl;   //true
    }
};
```

2 In a **const** member function, the object for which the function is called is accessed through a **const** access path; therefore, a **const** member function shall not modify the object and its non-static data members.

```cpp
struct s {
    int a;
    int f() const;
    int g() { return a++; }
    int h() const { return a++; } // error
};
int s::f() const { return a; }
```

The a++ in the body of s::h is ill-formed because it tries to modify (a part of) the object for which s::h() is called. This is not allowed in a const member function because this is a pointer to const; that is, *this has const type. — end example ]

调用const成员函数的对象是通过const访问途径(也就是说调用const成员函数的对象应该是const或const volatile), 并且const成员函数不能修改对象或数据成员.

3 Similarly, volatile semantics (7.1.6.1) apply in volatile member functions when accessing the object and its non-static data members.

4 A cv-qualified member function can be called on an object-expression (5.2.5) only if the object-expression is as cv-qualified or less-cv-qualified than the member function.

```cpp
void k(s& x, const s& y) {
    x.f();
    x.g();
    y.f();
    y.g(); // error
}
```

The call y.g() is ill-formed because y is const and s::g() is a non-const member function, that is, s::g() is less-qualified than the object-expression y. — end example ]

对象只能调用与自己具有相同或更多的cv限定符的成员函数.

5 Constructors (12.1) and destructors (12.4) shall not be declared **const**, **volatile** or **const volatile**. [ Note: However, these functions can be invoked to create and destroy objects with cv-qualified types, see (12.1) and(12.4). —endnote]

### 9.4 Static members

1 A data or function member of a class may be declared **static** in a class definition, in which case it is a *static member* of the class.

2 A **static** member s of class X may be referred to using the *qualified-id* expression **X::s**; it is not necessary to use the class member access syntax (5.2.5) to refer to a static member. A static member may be referred to using the class member access syntax, in which case the object expression is evaluated.

```cpp
struct process {
    static void reschedule();
};
process& g();
void f() {
    process::reschedule();  // OK: no object necessary
    g().reschedule();       // g() is called
}
```

3 A **static** member may be referred to directly in the scope of its class or in the scope of a class derived (Clause 10) from its class; in this case, the static member is referred to as if a *qualified-id* expression was used, with the *nested-name-specifier* of the *qualified-id* naming the class scope from which the static member is referenced.

```cpp
int g();
struct X {
    static int g();
};
struct Y : X {
    static int i;
    void f()
    {
        g(); // equivalent to X::g();
    }
};
int Y::i = g(); // equivalent to Y::g();    [9.4/4], [9.4.2/2]
```

4 If an *unqualified-id* (5.1) is used in the definition of a **static** member following the member’s *declarator-id*, and name lookup (3.4.1) finds that the *unqualified-id* refers to a static member, enumerator, or nested type of the member’s class (or of a base class of the member’s class), the *unqualified-id* is transformed into a *qualified-id* expression in which the *nested-name-specifier* names the class scope from which the member is referenced. [ Note: See 5.1 for restrictions on the use of non-static data members and non-static member functions. —endnote]

5 Static members obey the usual class member access rules (Clause 11). When used in the declaration of a class member, the static specifier shall only be used in the member declarations that appear within the member-specification of the class definition. [ Note: It cannot be specified in member declarations that appear in namespace scope. — end note ]

### 9.4.1 Static member functions

1 [ Note: The rules described in 9.3 apply to static member functions. — end note ]

2 [ Note: A static member function does not have a this pointer (9.3.2). — end note ] A **static** member function shall not be **virtual**. There shall not be a **static** and a non-static member function with the same name and the same parameter types (13.1). A **static** member function shall not be declared **const**, **volatile**, or **const volatile**.

### 9.4.2 Static data members

1 A **static** data member is not part of the subobjects of a class. If a **static** data member is declared **thread_local** there is one copy of the member per thread. If a **static** data member is not declared **thread_local** there is one copy of the data member that is shared by all the objects of the class.

2 The declaration of a **static** data member in its class definition is not a definition and may be of an incomplete type other than cv-qualified void. The definition for a **static** data member shall appear in a namespace scope enclosing the member’s class definition. In the definition at namespace scope, the name of the **static** data member shall be qualified by its class name using the :: operator. The initializer expression in the definition of a **static** data member is in the scope of its class (3.3.7).

```cpp
class process {
    static process* run_chain;
    static process* running;
};
process* process::running = get_main();
process* process::run_chain = running;  //process::running
```

The static data member **run_chain** of class **process** is defined in global scope; the notation **process:: run_chain** specifies that the member **run_chain** is a member of class **process** and in the scope of class process. In the static data member definition, the initializer expression refers to the static data member **running** of class **process**.

3 If a non-volatile *const static* data member is of integral or enumeration type, its declaration in the class definition can specify a *brace-or-equal-initializer* in which every *initializer-clause* that is an *assignment-expression* is a constant expression (5.19). A **static** data member of literal type can be declared in the class definition with the **constexpr** specifier; if so, its declaration shall specify a *brace-or-equal-initialize* in which every *initializer-clause* that is an *assignment-expression* is a constant expression. [ Note: In both these cases,the member may appear in constant expressions. —end note] The member shall still be defined in a namespace scope if it is odr-used (3.2) in the program and the namespace scope definition shall not contain an initializer.

```cpp
template<typename _Tp, _Tp __v>
struct integral_constant
{
      static constexpr _Tp                  value = __v;
      //...
};

template<typename _Tp, _Tp __v>
constexpr _Tp integral_constant<_Tp, __v>::value;
```

4 [ Note: There shall be exactly one definition of a static data member that is odr-used (3.2) in a program; no diagnostic is required. — end note ] Unnamed classes and classes contained directly or indirectly within unnamed classes shall not contain static data members.

```cpp
typedef struct {
    static int x;
    struct I
    {
        static int x;
    }
} unnamed_type;

int unnamed_type::x  = 0;   //error.
int unnamed_type::In::x  = 0;   //error.
```

5 **Static** data members of a class in namespace scope have external linkage (3.5). A local class shall not have static data members.

6 **Static** data members are initialized and destroyed exactly like non-local variables (3.6.2, 3.6.3).

7 A **static** data member shall not be mutable (7.1.1).

### 9.5 Unions

### 9.7 Nested class declarations

1 A class can be declared within another class. A class declared within another is called a *nested class*. The name of a nested class is local to its enclosing class. The nested class is in the scope of its enclosing class. [Note: See 5.1 for restrictions on the use of non-static data members and non-static member functions. — end note ]

```cpp
int x;
int y;
struct enclose {
    int x;
    static int s;
    struct inner {
        void f(int i) {
            int a = sizeof(x);  // OK: operand of sizeof is an unevaluated operand
            x=i;                // error: assign to enclose::x
            s=i;                // OK: assign to enclose::s
            ::x=i;              // OK: assign to global x
            y=i;                // OK: assign to global y
        }
        void g(enclose* p, int i) {
            p->x = i;           // OK: assign to enclose::x
        }
    };
};
inner* p = 0;                   // error: inner not in scope
```

2 Member functions and static data members of a nested class can be defined in a namespace scope enclosing
the definition of their class.

```cpp
struct enclose {
    struct inner {
        static int x;
        void f(int i);
    };
};
int enclose::inner::x = 1;
void enclose::inner::f(int i) { /∗ ... ∗/ }
```

3 If class X is defined in a namespace scope, a nested class Y may be declared in class X and later defined in the
definition of class X or be later defined in a namespace scope enclosing the definition of class X.

```cpp
class E {
    class I1;       // forward declaration of nested class
    class I2;
    class I1 { };   // definition of nested class
};
class E::I2 { };    // definition of nested class
```

4 Like a member function, a friend function (11.3) defined within a nested class is in the lexical scope of that class; it obeys the same rules for name binding as a static member function of that class (9.4), but it has no special access rights(权利) to members of an enclosing class.

### 9.8 Local class declarations

1 A class can be declared within a function definition; such a class is called a *local class*. The name of a local class is local to its enclosing scope. The local class is in the scope of the enclosing scope, and has the same access to names outside the function as does the enclosing function. Declarations in a local class shall not odr-use (3.2) a variable with automatic storage duration from an enclosing scope.

```cpp
int x;
void f() {
    static int s ;
    int x;
    const int N = 5;
    extern int q();
    struct local {
        int g() { return x; }     // error: odr-use of automatic variable x
        int h() { return s; }     // OK
        int k() { return ::x; }   // OK
        int l() { return q(); }   // OK
        int m() { return N; }     // OK: not an odr-use
        int *n() { return &N; }   // error: odr-use of automatic variable N
    };
}
local* p = 0;                     // error: local not in scope
```

2 An enclosing function has no special access to members of the local class; it obeys the usual access rules (Clause 11). Member functions of a local class shall be defined within their class definition, if they are defined at all.

3 If class X is a local class a nested class Y may be declared in class X and later defined in the definition of class X or be later defined in the same scope as the definition of class X. A class nested within a local class is a local class.

4 A local class shall not have static data members.

### 9.9 Nested type names

1 Type names obey exactly the same scope rules as other names. In particular, type names defined within a class definition cannot be used outside their class without qualification.

```cpp
struct X {
    typedef int I;
    class Y { /∗...∗/ };
    I a;
};
I b;    // error
Y c;    // error
X::Y d; // OK
X::I e; // Ok
```

### 1.8 The C++ object model

2 Objects can contain other objects, called *subobjects*. A subobject can be a *member subobject*(9.2), a *base class subobject* (Clause 10), or an array element. An object that is not a subobject of any other object is called a *complete object*.

3 For every object x, there is some object called the *complete object of* **x**, determined as follows:

— If x is a complete object, then x is the complete object of x.
— Otherwise, the complete object of x is the complete object of the (unique) object that contains x.

4 If a *complete object*, a data member (9.2), or an array element is of class type, its type is considered the *most derived class*, to distinguish it from the class type of any base class subobject; an object of a most derived class type or of a non-class type is called a *most derived object*.

### 10 Derived classes

1 A list of base classes can be specified in a class definition using the notation:

*base-clause:
    : base-specifier-list
base-specifier-list:
    base-specifier ...opt
    base-specifier-list , base-specifier ...opt
base-specifier:
    attribute-specifier-seqopt base-type-specifier
    attribute-specifier-seqopt virtual access-specifieropt base-type-specifier
    attribute-specifier-seqopt access-specifier virtualopt base-type-specifier
class-or-decltype:
    nested-name-specifieropt class-name
    decltype-specifier
base-type-specifier:
    class-or-decltype
access-specifier:
    private
    protected
    public*

The optional *attribute-specifier-seq* appertains to the *base-specifier*.

2 The type denoted by a *base-type-specifier* shall be a class type that is not an incompletely defined class (Clause 9); this class is called a *direct base class* for the class being defined. During the lookup for a base class name, non-type names are ignored (3.3.10). If the name found is not a class-name, the program is ill-formed. A class **B** is a base class of a class D if it is a direct base class of D or a direct base class of one of D’s base classes. A class is an indirect base class of another if it is a base class but not a direct base class. A class is said to be (directly or indirectly) derived from its (direct or indirect) base classes. [Note: See Clause 11 for the meaning of access-specifier . — end note ] Unless redeclared in the derived class, members of a base class are also considered to be members of the derived class. The base class members are said to be inherited by the derived class. Inherited members can be referred to in expressions in the same manner(方式) as other members of the derived class, unless their names are hidden or ambiguous (10.2). [ Note: The scope resolution operator :: (5.1) can be used to refer to a direct or indirect base member explicitly. This allows access to a name that has been redeclared in the derived class. A derived class can itself serve as(作为,充当) a base class subject to(依照...) access control; see 11.2. A pointer to a derived class can be implicitly converted to a pointer to an accessible unambiguous base class (4.10). An lvalue of a derived class type can be bound to a reference to an accessible unambiguous base class (8.5.3). — end note ]

3 The *base-specifier-list* specifies the type of the *base class subobjects* contained in an object of the derived class type.

```cpp
struct Base {
    int a, b, c;
};
struct Derived : Base {
    int b;
};
struct Derived2 : Derived {
    int c;
};
```

Here, an object of class **Derived2** will have a subobject of class **Derived** which in turn(相应地) will have a subobject of class **Base**.

4 A *base-specifier* followed by an ellipsis is a pack expansion(展开) (14.5.3).

```cpp
struct A
{
	void f(){
		std::cout << __func__ << std::endl;
	}
};

struct B
{
	void g(){
		std::cout << __func__ << std::endl;
	}
};

template<typename... Bases>
struct D : Bases...             //可以同时继承多个基类, 取决于模板实参个数.
{
	void h(){
		this->f(); //ok
		this->g(); //ok
	}
};
```

5 The order in which the base class subobjects are allocated in the most derived object (1.8) is unspecified. [ Note: A derived class and its base class subobjects can be represented by a directed acyclic graph (DAG) where an arrow means “directly derived from”. An arrow need not have a physical representation in memory. A DAG of subobjects is often referred to as a “subobject lattice”. — end note ]

<img src="imgs/classes-imgs/Figure2.png" style="zoom:50%" />

8 [Note: A base class subobject might have a layout (3.7) different from the layout of a most derived object of the same type. A base class subobject might have a polymorphic behavior (12.7) different from the polymorphic behavior of a most derived object of the same type. A base class subobject may be of zero size (Clause 9); however, two subobjects that have the same class type and that belong to the same most derived object must not be allocated at the same address (5.10). — end note ]

```cpp
class B
{
    virtual void g()
    {
        std::cout << "B::g" << std::endl;
    }
};

class D : public B
{
    virtual void g()
    {
        std::cout << "D::g" << std::endl;
    }
};

void f()
{
    B b;
    D d; //当B类对象分别作为d的基类子对象和最派生对象(most derived objec)时具有不同的布局, 并且也具有不同的多态行为.
}
```

### 10.1 Multiple base classes

1 A class can be derived from any number of base classes. [ Note: The use of more than one direct base class is often called multiple inheritance. — end note ]

```cpp
class A { /∗...∗/ };
class B { /∗...∗/ };
class C { /∗...∗/ };
class D : public A, public B, public C { /∗ ... ∗/ };
```

3 A class shall not be specified as a direct base class of a derived class more than once. [Note: A class can be an indirect base class more than once and can be a direct and an indirect base class. There are limited things that can be done with such a class(这样的类可以做的事情是有限的). The non-static data members and member functions of the direct base class cannot be referred to in the scope of the derived class. However, the static members, enumerations and types can be unambiguously referred to. — end note ]

```cpp
class X { /∗...∗/ };
class Y : public X, public X { /∗ ... ∗/ }; // ill-formed
class L { public: int next; /∗ ... ∗/ };
class A : public L { /∗...∗/ };
class B : public L { /∗...∗/ };
class C : public A, public B { void f(); /∗ ... ∗/ }; // well-formed
class D : public A, public L { void f(); /∗ ... ∗/ }; // well-formed
```

```cpp
class L {
public:
	int next;
	enum {e = 0};
	typedef int T;
};
class A : public L { /* ... */ };
class B : public L { /* ... */ };
class C : public A, public B {
    void f(){
        T i = e;
        //T j = next;	//error
    }
};
class D : public A, public L {
    void f(){
        T i = e;
        //T j = next;	//error
    }
};
```

4 A base class specifier that does not contain the keyword **virtual** specifies a *non-virtual base class*. A base class specifier that contains the keyword **virtual** specifies a *virtual base class*. For each distinct occurrence of a non-virtual base class in the class lattice of the most derived class, the most derived object (4.5) shall contain a corresponding distinct base class subobject of that type. For each distinct base class that is specified virtual, the most derived object shall contain a single base class subobject of that type.

对于最派生对象的类格中出现的每个不同的非虚基类, 这个最派生对象都应该包含一个相应的基类子对象. ...

5 [Note: For an object of class type C, each distinct occurrence of a (non-virtual) base class L in the class lattice of C corresponds one-to-one with a distinct L subobject within the object of type C. Given the class C defined above, an object of class C will have two subobjects of class L as shown in Figure 3.

<img src="imgs/classes-imgs/Figure3.png" style="zoom:50%" />

In such lattices, explicit qualification can be used to specify which subobject is meant. The body of function C::f could refer to the member next of each L subobject:

```
void C::f() { A::next = B::next; } // well-formed
```

Without the A:: or B:: qualifiers, the definition of C::f above would be ill-formed because of ambiguity (13.2).

6 [ Note: In contrast, consider the case with a virtual base class:

```
class V { /* ... */ };
class A : virtual public V { /* ... */ };
class B : virtual public V { /* ... */ };
class C : public A, public B { /* ... */ };
```

<img src="imgs/classes-imgs/Figure4.png" style="zoom:50%" />

For an object c of class type C, a single subobject of type V is shared by every base class subobject of c that has a virtual base class of type V. Given the class C defined above, an object of class C will have one subobject of class V, as shown in Figure 4. — end note ]

7 [ Note: A class can have both virtual and non-virtual base classes of a given type.

```
class B { /* ... */ };
class X : virtual public B { /* ... */ };
class Y : virtual public B { /* ... */ };
class Z : public B { /* ... */ };
class AA : public X, public Y, public Z { /* ... */ };
```

For an object of class AA, all **virtual** occurrences of base class B in the class lattice of AA correspond to a single B subobject within the object of type AA, and every other occurrence of a (non-virtual) base class B in the class lattice of AA corresponds one-to-one with a distinct B subobject within the object of type AA. Given the class AA defined above, class AA has two subobjects of class B: Z’s B and the virtual B shared by X and Y, as shown in Figure 5.

对于一个AA类的对象, 在AA的类格中出现的所有虚基类B都对应到(这个AA类型对象中的)唯一的B类子对象, 并且每个在AA的类格中出现的非虚基类B都一一对应到(这个AA类型对象中的)不同的B类子对象.

<img src="imgs/classes-imgs/Figure5.png" style="zoom:50%" />

### 10.3 Virtual functions

1 Virtual functions support dynamic binding and object-oriented programming. A class that declares or inherits a virtual function is called a *polymorphic class*.

2 If a virtual member function **vf** is declared in a class **Base** and in a class **Derived**, derived directly or indirectly from Base, a member function **vf** with the same name, parameter-type-list (8.3.5), cv-qualification, and ref-qualifier (or absence of same) as Base::vf is declared, then Derived::vf is also virtual (whether or not it is so declared) and it *overrides* 111 Base::vf. For convenience(方便) we say that any virtual function overrides itself. A virtual member function C::vf of a class object S is a *final overrider* unless the most derived class (1.8) of which S is a base class subobject (if any) declares or inherits another member function that overrides vf. In a derived class, if a virtual member function of a base class subobject has more than one final overrider the program is ill-formed.

一个类对象S的虚成员函数C::vf是一个*final overrider*, 除非S是一个最派生类对象的基类子对象,并且这个最派生类中声明或继承了其它覆盖vf的成员函数.

```cpp
struct A {
    virtual void f();
};
struct B : virtual A {
    virtual void f();
};
struct C : B , virtual A {
    using A::f;
};
void foo() {
    C c;
    c.f();      // calls B::f, the final overrider
    c.C::f();   // calls A::f because of the using-declaration
}
```

```cpp
struct A { virtual void f(); };
struct B : A { };
struct C : A { void f(); };
struct D : B, C { };    // OK: A::f and C::f are the final overriders
                        // for the B and C subobjects, respectively
                        // 因为最派生类D中没有声明或继承其他覆盖vf的成员函数
```

> A function with the same name but a different parameter list (Clause 13) as a virtual function is not necessarily virtual and does not override. The use of the virtual specifier in the declaration of an overriding function is legal but redundant (多余的)(has empty semantics). Access control (Clause 11) is not considered in determining overriding.
> 

3 [ Note: A virtual member function does not have to be visible to be overridden, for example,

不可见的virtual成员函数也可以被覆盖

```cpp
struct B {
    virtual void f();
};

struct D : B {
    void f(int);    //隐藏 B::f(), 不是虚函数.
};
struct D2 : D {
    void f();   //覆盖(重写) B::f, 是虚函数.
};
```

the function f(int) in class D hides the virtual function f() in its base class B; D::f(int) is not a virtual function. However, f() declared in class D2 has the same name and the same parameter list as B::f(), and therefore is a virtual function that overrides the function B::f() even though B::f() is not visible in class D2. —endnote]

4 If a virtual function f in some class B is marked with the *virt-specifier* **final** and in a class D derived from B a function D::f overrides B::f, the program is ill-formed.

final 关键字禁止覆盖虚函数

```cpp
struct B {
    virtual void f() const final;
};
struct D : B {
    void f() const; // error: D::f attempts to override final B::f
};
```

5 If a virtual function is marked with the *virt-specifier* **override** and does not override a member function of a base class, the program is ill-formed.

override 关键字用法: 显式表明虚函数是用于覆盖基类的虚函数, 而防止不小心写成隐藏.

```cpp
struct B {
  virtual void f(int);
};
struct D : B {
  void f(long) override;    // error: wrong signature overriding B::f
  void f(int) override;     // OK
};

struct Y : public B
{
    void f(); //隐藏B::f
};
```

6 Even though destructors are not inherited, a destructor in a derived class overrides a base class destructor declared virtual; see 12.4 and 12.5.

7 The return type of an overriding function shall be either identical to(与...相同) the return type of the overridden function or covariant(协变的) with the classes of the functions. If a function D::f overrides a function B::f, the return types of the functions are covariant if they satisfy(满足) the following criteria(准则):

协变返回类型的要求:

— both are pointers to classes, both are lvalue references to classes, or both are rvalue references to classes 112

— the class in the return type of B::f is the same class as the class in the return type of D::f, or is an unambiguous and accessible direct or indirect base class of the class in the return type of D::f

— both pointers or references have the same cv-qualification and the class type in the return type of D::f has the same cv-qualification as or less cv-qualification than the class type in the return type of B::f.

8 If the return type of D::f differs from the return type of B::f, the class type in the return type of D::f shall be complete at the point of declaration of D::f or shall be the class type D. When the overriding function is called as the final overrider of the overridden function, its result is converted to the type returned by the (statically chosen) overridden function (5.2.2).

```cpp
class B { };
class D : private B { friend class Derived; };
struct Base {
    virtual void vf1();
    virtual void vf2();
    virtual void vf3();
    virtual B*   vf4();
    virtual B*   vf5();
    void f();
};
struct No_good : public Base {
    D* vf4(); // error: B (base class of D) inaccessible
};

class A;
struct Derived : public Base {
    void vf1();     // virtual and overrides Base::vf1()
    void vf2(int);  // not virtual, hides Base::vf2()
    char vf3();     // error: invalid difference in return type only
    D*   vf4();     // OK: returns pointer to derived class
    A*   vf5();     // error: returns pointer to incomplete class
    void f();
};

void g() {
    Derived d;
    Base* bp = &d;                // standard conversion:
                                  // Derived* to Base*
    bp->vf1();                    // calls Derived::vf1()
    bp->vf2();                    // calls Base::vf2()
    bp->f();                      // calls Base::f() (not virtual)
    B*  p = bp->vf4();            // calls Derived::vf4() and converts the
                                  // result to B*
    Derived*  dp = &d;
    D*  q = dp->vf4();            // calls Derived::vf4() and does not
                                  // convert the result to B*
    dp->vf2();                    // ill-formed: argument mismatch
}
```

9 [Note: The interpretation(解释) of the call of a virtual function depends on the type of the object for which it is called (the dynamic type), whereas the interpretation of a call of a non-virtual member function depends only on the type of the pointer or reference denoting that object (the static type) (5.2.2). — end note ]

> [5.2.2/1] If a function or member function name is used, the name can be overloaded (Clause 13), in which case the appropriate function shall be selected according to the rules in 13.3. If the selected function is non-virtual, or if the id-expression in the class member access expression is a qualified-id, that function is called. Otherwise, its final overrider (10.3) in the dynamic type of the object expression is called.
> 

10 [Note: The **virtual** specifier implies membership, so a virtual function cannot be a nonmember (7.1.2) function. Nor can a **virtual** function be a static member, since a virtual function call relies on(依赖于) a specific object for determining which function to invoke. A virtual function declared in one class can be declared a friend in another class. — end note ]

11 A virtual function declared in a class shall be defined, or declared pure (10.4) in that class, or both; but no diagnostic is required (3.2).

2 [ Example: here are some uses of virtual functions with multiple base classes:

```cpp
struct A {
    virtual void f();
};
struct B1 : A {
    void f();
};
struct B2 : A {     // note non-virtual derivation
    void f();
};
struct D : B1, B2 { // D has two separate(单独的) A subobjects
};
void foo() {
    D   d;
    // A* ap = &d; // would be ill-formed: ambiguous
    B1* b1p = &d;
    A* ap = b1p;
    D* dp = &d;
    ap->f();        // calls D::B1::f
    dp->f();        // ill-formed: ambiguous
}
```

In class D above there are two occurrences of class A and hence two occurrences of the virtual member function A::f. The final overrider of B1::A::f is B1::f and the final overrider of B2::A::f is B2::f.

13 The following example shows a function that does not have a unique final overrider:

```cpp
struct A {
  virtual void f();
};
struct VB1 : virtual A {    // note virtual derivation
  void f();
};
struct VB2 : virtual A {
  void f();
};
struct Error : VB1, VB2 {   // ill-formed
};
struct Okay : VB1, VB2 {
  void f();
};
```

Both VB1::f and VB2::f override A::f but there is no overrider of both of them in class Error. This example is therefore ill-formed. Class Okay is well formed, however, because Okay::f is a final overrider.

14 The following example uses the well-formed classes from above.

```cpp
struct VB1a : virtual A {   // does not declare f
};
struct Da : VB1a, VB2 {
};
void foe() {
    VB1a*  vb1ap = new Da;
    vb1ap->f();   // calls VB2::f
}
```

15 Explicit qualification with the scope operator (5.1) suppresses(抑制, 压制) the virtual call mechanism.

```cpp
class B { public: virtual void f(); };
class D : public B { public: void f(); };

void D::f() { /∗ ... ∗/ B::f(); }
```

Here, the function call in D::f really does call B::f and not D::f.

16 A function with a deleted definition (8.4) shall not override a function that does not have a deleted definition. Likewise, a function that does not have a deleted definition shall not override a function with a deleted definition.

### 10.4 Abstract classes

1 The abstract class mechanism supports the notion of a general concept, such as a shape, of which only more concrete variants, such as circle and square, can actually be used. An abstract class can also be used to define an interface for which derived classes provide a variety of implementations.

抽象类机制用于支持那些一般概念中尚未确定的概念. 例如"形状", 它有只有更多具体的变体, 如"圆形"和"方形".

2 An abstract class is a class that can be used only as a base class of some other class; no objects of an abstract class can be created except as subobjects of a class derived from it. A class is abstract if it has at least one *pure virtual function*. [ Note: Such a function might be inherited: see below. — end note ] A virtual function is specified *pure* by using a *pure-specifier* (9.2) in the function declaration in the class definition. A pure virtual function need be defined only if called with, or as if with (12.4), the *qualified-id* syntax (5.1).

```cpp
class point { /∗ ... ∗/ };
class shape { // abstract class
    point center;
public:
    point where() { return center; }
    void move(point p) { center=p; draw(); }
    virtual void rotate(int) = 0; // pure virtual
    virtual void draw() = 0; // pure virtual
};
```

[ Note: A function declaration cannot provide both a *pure-specifier* and a definition — end note ]

```cpp
struct C {
    virtual void f() = 0 { }; // ill-formed
};
```

3 An abstract class shall not be used as a parameter type, as a function return type, or as the type of an explicit conversion. Pointers and references to an abstract class can be declared.

```
shape x;            // error: object of abstract class
shape* p;           // OK
shape f();          // error
void g(shape);      // error
shape& h(shape&);   // OK
```

4 A class is abstract if it contains or inherits at least one pure virtual function for which the final overrider is pure virtual.

```
class ab_circle : public shape {
    int radius;
public:
    void rotate(int) { }
    // ab_circle::draw() is a pure virtual
};
```

Since **shape::draw()** is a pure virtual function **ab_circle::draw()** is a pure virtual by default. The alternative(替代的) declaration,

```
class circle : public shape {
  int radius;
public:
  void rotate(int) { }
  void draw();  // a definition is required somewhere
};
```

would make class **circle** nonabstract and a definition of **circle::draw()** must be provided.

5 [ Note: An abstract class can be derived from a class that is not abstract, and a pure virtual function may override a virtual function which is not pure. — end note ]

6 Member functions can be called from a constructor (or destructor) of an abstract class; the effect of making a virtual call (10.3) to a pure virtual function directly or indirectly for the object being created (or destroyed) from such a constructor (or destructor) is undefined.

```
struct B {
  virtual void f() = 0;
  B(){
	  this->f();   //ub.
  }
};

struct D : public B
{
    virtual void f()
    {

    }
};
```

### 11 Member access control

1 A member of a class can be

— **private**; that is, its name can be used only by members and friends of the class in which it is declared.

— **protected**; that is, its name can be used only by members and friends of the class in which it is declared, by classes derived from that class, and by their friends (see 11.4).

— **public**; that is, its name can be used anywhere without access restriction.

2 A member of a class can also access all the names to which the class has access. A local class of a member
function may access the same names that the member function itself may access. 113

3 Members of a class defined with the keyword **class** are **private** by default. Members of a class defined
with the keywords **struct** or **union** are **public** by default.

```cpp
  class X {
    int a;
};
  struct S {
    int a;
};
```

4 Access control is applied uniformly(一致地) to all names, whether the names are referred to from declarations or expressions. [ Note: Access control applies to names nominated(指定) by friend declarations (11.3) and using-declarations (7.3.3). — end note ] In the case of overloaded function names, access control is applied to the function selected by overload resolution. [ Note: Because access control applies to names, if access control is applied to a typedef name, only the accessibility of the typedef name itself is considered. The accessibility of the entity referred to by the typedef is not considered. For example,

```cpp
  class A {
    class B { };
  public:
    typedef B BB;
};
  void f() {
    A::BB x;    // OK, typedef name A::BB is public
    A::B y;     // access error, A::B is private
}
```

5 It should be noted that it is *access* to members and base classes that is controlled, not their visibility. Names of members are still visible, and implicit conversions to base classes are still considered, when those members and base classes are inaccessible. The interpretation of a given construct is established without regard to access control. If the interpretation established makes use of inaccessible member names or base classes, the construct is ill-formed.

应该注意的是, 访问受控制的是成员和基类, 不是它们的可见性.
后面两句是说在解释语言构造的时候不会将访问控制考虑在内, 但是被确定的语言构造的解释中如果利用了不可访问的成员名或基类, 则这个构造是ill-formed.
比如在进行重载解析时, 就不会考虑访问控制, 所以即使是具有private访问控制的成员函数也会参与重载解析, 但是, 如果重载解析选择出来的最佳匹配的函数就是具有private访问控制的函数, 并且对象不能访问这个函数的话, 则这个函数调用是ill-formed

```cpp
struct C
{
private:
    void f(int);
public:
    void f();
};

void g(){
    C c;
    c.f(1); //ill-formed;
}
```

6 All access controls in Clause 11 affect the ability to access a class member name from the declaration of a particular entity, including parts of the declaration preceding the name of the entity being declared and, if the entity is a class, the definitions of members of the class appearing outside the class’s *member-specification*. [ Note: this access also applies to implicit references to constructors, conversion functions, and destructors. — end note ]

第11章中的所有访问控制都会影响从一个特定实体的声明中访问一个类成员名称的能力, 包括正在被声明的实体名称前面的声明部分(如下面的 A::I), 并且如果被声明的实体是一个类, 则也包括出现在这个类的成员说明符外部的类成员定义.

```cpp
class A {
    typedef int I;  //private member
    I f();
    friend I g(I);
    static I x;
    template<int> struct Q;
    template<int> friend struct R;
protected:
    struct B { };
};
A::I A::f() { return 0; }
A::I g(A::I p = A::x);
A::I g(A::I p) { return 0; }
A::I A::x = 0;
template<A::I> struct A::Q { };
template<A::I> struct R { };

struct D: A::B, A { };
```

7 Here, all the uses of A::I are well-formed because A::f, A::x, and A::Q are members of class A and g and R are friends of class A. This implies, for example, that access checking on the first use of A::I must be deferred until it is determined that this use of A::I is as the return type of a member of class A. Similarly, the use of A::B as a base-specifier is well-formed because D is derived from A, so checking of base-specifiers must be deferred until the entire base-specifier-list has been seen.

8 The names in a default argument (8.3.6) are bound at the point of declaration, and access is checked at that point rather than at any points of use of the default argument. Access checking for default arguments in function templates and in member functions of class templates is performed as described in 14.7.1.

默认参数名的访问检查发生在其声明点, 而不是使用默认参数的时候.

9 The names in a default *template-argument* (14.1) have their access checked in the context in which they appear rather than at any points of use of the default *template-argument*.

默认模板参数的访问检查发生在它们出现的上下文

```cpp
class B { };
template <class T> class C {
protected:
    typedef T TT;
};
template <class U, class V = typename U::TT>
class D : public U { };
D <C<B> >* d; // access error, C::TT is protected
```

### 11.1 Access specifiers

1 Member declarations can be labeled by an *access-specifier* (Clause 10):

*access-specifier : member-specificationopt*

An *access-specifier* specifies the access rules for members following it until the end of the class or until another *access-specifier* is encountered(遇到).

```cpp
class X {
  int a;    // X::a is private by default: class used
public:
  int b;    // X::b is public
  int c;    // X::c is public
};
```

2 Any number of access specifiers is allowed and no particular order is required.

```cpp
struct S {
  int a;    // S::a is public by default: struct used
protected:
  int b;    // S::b is protected
private:
  int c;    // S::c is private
public:
  int d;    // S::d is public
};
```

3 [Note: The effect of access control on the order of allocation of data members is described in 9.2.—end note ]

4 When a member is redeclared within its class definition, the access specified at its redeclaration shall be the same as at its initial declaration.

```cpp
struct S {
     class A;
     enum E : int;
private:
    class A { };        // error: cannot change access
    enum E: int { e0 }; // error: cannot change access
};
```

5 [Note: In a derived class, the lookup of a base class name will find the injected-class-name instead of the name of the base class in the scope in which it was declared. The injected-class-name might be less accessible than the name of the base class in the scope in which it was declared. — end note ]

在派生类中, 对基类名称查找将会找到*injected-class-name*而不是由基类声明所引入到作用域的名称.被找到的*injected-class-name*的可访问性可能少于基类声明所引入到作用域的名称.

```cpp
class A { };
class B : private A { };
class C : public B {
    A *p;       // error: injected-class-name A is inaccessible
    ::A *q;     // OK
                //A的声明引入名称A到::作用域.
};
```

### 11.2 Accessibility of base classes and base class members

1 If a class is declared to be a base class (Clause 10) for another class using the **public** access specifier, the **public** members of the base class are accessible as **public** members of the derived class and **protected** members of the base class are accessible as **protected** members of the derived class. If a class is declared to be a base class for another class using the **protected** access specifier, the **public** and **protected** members of the base class are accessible as **protected** members of the derived class. If a class is declared to be a base class for another class using the **private** access specifier, the **public** and **protected** members of the base class are accessible as **private** members of the derived class 114

public继承:
基类的public成员的可访问性如同派生类的public成员.
基类的protected成员的可访问性如同派生类的protected成员.

protected继承:
基类的public成员和protected成员的可访问性都如同派生类的protected成员.

private继承:
基类的public成员和protected成员的可访问性都如同派生类的private成员.

2 In the absence of(缺少, 没有) an *access-specifier* for a base class, **public** is assumed(被假定) when the derived class is defined with the *class-key* **struct** and **private** is assumed when the class is defined with the *class-key* **class**.

```
class B { /∗...∗/ };
class D1 : private B { /∗...∗/ };
class D2 : public B { /∗...∗/ };
class D3 : B { /∗...∗/ }; //B private by default
struct D4 : public B { /∗...∗/ };
struct D5 : private B { /∗ ... ∗/ };
struct D6 : B { /∗...∗/ }; //B public by default
class D7 : protected B { /∗ ... ∗/ };
struct D8 : protected B { /∗ ... ∗/ };
```

Here B is a public base of D2, D4, and D6, a private base of D1, D3, and D5, and a protected base of D7 and D8.

3 [ Note: A member of a private base class might be inaccessible as an inherited member name, but accessible directly. Because of the rules on pointer conversions (4.10) and explicit casts (5.4), a conversion from a pointer to a derived class to a pointer to an inaccessible base class might be ill-formed if an implicit conversion is used, but well-formed if an explicit cast is used. For example,

```cpp
class B {
public:
    int mi;             // non-static member
    static int si;      // static member
};
class D : private B { };
class DD : public D {
    void f();
};

void DD::f() {
    mi = 3;                 // error: mi is private in D
    si = 3;                 // error: si is private in D
    ::B  b;
    b.mi = 3;               // OK (b.mi is different from this->mi)
    b.si = 3;               // OK (b.si is different from this->si)
    ::B::si = 3;            // OK
    ::B* bp1 = this;        // error: B is a private base class
    ::B* bp2 = (::B*)this;  // OK with cast
    bp2->mi = 3;            // OK: access through a pointer to B.
}
```

4 A base class **B** of **N** is *accessible* at **R**, if

— an invented public member of B would be a public member of N, or

— R occurs in a member or friend of class N, and an invented public member of B would be a private or protected member of N, or

— R occurs in a member or friend of a class P derived from N, and an invented public member of B would be a private or protected member of P, or

— there exists a class S such that B is a base class of S accessible at R and S is a base class of N accessible at R.

对基类可访问性定义

```cpp
class B {
public:
    int m;
};

class N1 : private B {
    B* p = this;     //ok, B是N1的可访问基类, 根据2.
};
class N2 : protected B {
    B* p = this;     //ok, B是N1的可访问基类, 根据2.
};
class N3 : public B {
    B* p = this;     //ok, B是N1的可访问基类, 根据1.
};
```

```cpp
class B {
public:
    int m;
};

class N: private B {

};
class P: private N {
    void f() {
        B* p = this;    //error, B不是P的可访问基类.
        N* n = this;    //ok, N是P的可访问基类, 符合2.
    }
};

class N2: protected B {

};

class P2: private N2 {
    void f() {
        B* p = this;    //ok, B是P2的可访问基类, 符合3.
        N2* n2 = this;  //ok, N2是P2的可访问基类, 符合2.
    }
};
```

```cpp
class B {
public:
    int m;
};
class S: private B {
    friend class N;
};
class N: private S {
    void f() {
        B* p = this;
            // OK because class S satisfies the fourth condition
            // above: B is a base class of N accessible in f() because
            // B is an accessible base class of S and S is an accessible
            // base class of N.

            //符合4, 由于友元声明使得S变成N的可访问基类.
    }
};
```

5 If a base class is accessible, one can implicitly convert a pointer to a derived class to a pointer to that base class (4.10, 4.11). [ Note: It follows that(由此可见) members and friends of a class X can implicitly convert an **X*** to a pointer to a private or protected immediate(直接的) base class of X. — end note ]

由此可见, 类X的成员和友元可以隐式地将X*转换为指向X的私有或保护的直接基类的指针

The access to a member is affected by the class in which the member is named. This naming class is the class in which the member name was looked up and found. [Note: This class can be explicit, e.g., when a *qualified-id* is used, or implicit, e.g., when a class member access operator (5.2.5) is used (including cases where an implicit “**this->**” is added). If both a class member access operator and a *qualified-id* are used to name the member (as in **p->T::m**), the class naming the member is the class denoted by the *nested-name-specifier* of the *qualified-id* (that is, **T**). — end note ] A member **m** is accessible at the point **R** when named in class **N** if

— m as a member of N is public, or

— m as a member of N is private, and R occurs in a member or friend of class N, or

— m as a member of N is protected, and R occurs in a member or friend of class N, or in a member or friend of a class P derived from N, where m as a member of P is public, private, or protected, or

— there exists a base class B of N that is accessible at R, and m is accessible at R when named in class B.

对成员的可访问性定义

```cpp
class B;
class A {
private:
    int i;
    friend void f(B*);
};
class B : public A { };
void f(B* p) {
    p->i = 1;   // OK: B* can be implicitly converted to A*,
                // and f has access to i in A
}
```

```cpp
class A
{
protected:
	int i = 1;
};

class B : private A
{
public:
	void f(){
		i = 0;
	}
};

B b;
b.f(); //ok
```

6 If a class member access operator, including an implicit “**this->**,” is used to access a non-static data member or non-static member function, the reference is ill-formed if the left operand (considered as a pointer in the “.” operator case) cannot be implicitly converted to a pointer to the naming class of the right operand. [ Note: This requirement is in addition to the requirement that the member be accessible as named. — end note ]

```
struct A
{
	int m;
};

class B : private A
{
};

class C : public B
{
	void f(){
		this->m = 0; //error, this不能转换为指向A的指针, 因为A对于C类对象而言是不可访问的基类.
	}
};
```

### 11.3 Friends

1 A friend of a class is a function or class that is given permission to use the private and protected member names from the class. A class specifies its friends, if any, by way of friend declarations. Such declarations give special access rights to the friends, but they do not make the nominated friends members of the befriending class.(友元声明不会引入成员名) [ Example: the following example illustrates the differences between members and friends:

```
class X {
    int a;
    friend void friend_set(X*, int);
    public:
    void member_set(int);
};
void friend_set(X* p, int i) { p->a = i; }
void X::member_set(int i) { a = i; }
void f() {
    X obj;
    friend_set(&obj,10);
    obj.member_set(10);
}
```

2 Declaring a class to be a friend implies that the names of private and protected members from the clas granting friendship(指A) can be accessed in the *base-specifiers* and member declarations of the befriended class (指X).

```
class A {
    class B { };
    friend class X;
};
struct X : A::B {   // OK: A::B accessible to friend
    A::B mx;        // OK: A::B accessible to member of friend
    class Y {
        A::B my;    // OK: A::B accessible to nested member of friend
    };
};
```

```
class X {
    enum { a=100 };
    friend class Y;
};
class Y {
    int v[X::a];  //OK, Y is a friend of X
};
class Z {
    int v[X::a];  //error: X::a is private
};
```

A class shall not be defined in a friend declaration.

```
class A {
    friend class B { }; // error: cannot define class in friend declaration
};
```

3 A friend declaration that does not declare a function shall have one of the following forms:

```
friend elaborated-type-specifier ;
friend simple-type-specifier ;
friend typename-specifier ;
```

[Note: A friend declaration may be the declaration in a *template-declaration* (Clause 14, 14.5.4).—end note ] If the type specifier in a **friend** declaration designates a (possibly cv-qualified) class type, that class is declared as a **friend**; otherwise, the friend declaration is ignored.

```
class C;
typedef C Ct;
class X1 {
    friend C; // OK: class C is a friend
};
class X2 {
    friend Ct;    // OK: class C is a friend
    friend D;     // error: no type-name D in scope
    friend class D;   // OK: elaborated-type-specifier declares new class
};

template <typename T> class R {
    friend T;
};

R<C> rc; // class C is a friend of R<C>
R<int> Ri; // OK: "friend int;" is ignored
```

4 A function first declared in a friend declaration has external linkage (3.5). Otherwise, the function retains its previous linkage (7.1.1).

5 When a friend declaration refers to an overloaded name or operator, only the function specified by the parameter types becomes a friend. A member function of a class X can be a friend of a class Y.

```
class Y {
  friend char* X::foo(int);
  friend X::X(char);    // constructors can be friends
  friend X::~X();       // destructors can be friends
};
```

6 A function can be defined in a friend declaration of a class if and only if the class is a non-local class (9.8),
the function name is unqualified, and the function has namespace scope.

```
class M {
    friend void f() { } // definition of global f, a friend of M,
                        // not the definition of a member function
};
```

7 Such a function is implicitly **inline**. A friend function defined in a class is in the (lexical) scope of the
class in which it is defined. A friend function defined outside the class is not (3.4.1).

8 No *storage-class-specifier* shall appear in the *decl-specifier-seq* of a friend declaration.

9 A name nominated by a friend declaration shall be accessible in the scope of the class containing the friend declaration. The meaning of the friend declaration is the same whether the friend declaration appears in the **private**, **protected** or **public** (9.2) portion of the class *member-specification*.

10 Friendship is neither inherited nor transitive.

友元不可继承也不可传递.

```cpp
class A {
    friend class B;
    int a;
};
class B {
    friend class C;
};
class C  {
    void f(A* p) {
        p->a++; // error: C is not a friend of A
                // despite being a friend of a friend
    }
};

class D : public B  {
    void f(A* p) {
        p->a++; // error: D is not a friend of A
                // despite being derived from a friend
    }
};
```

```cpp
class A {
protected: //必须是protected或是public, 如果使用private, 则根据[11.2/5], 成员m在派生类中不可访问.
    int m;
};
class B : private A {
    friend class D;
};

class D
{
    void f(B* b){
        b->m = 0;   //ok.
    }
};
```

### 11.4 Protected member access

1 An additional access check beyond(除...以外) those described earlier in Clause 11 is applied when a non-static data member or non-static member function is a protected member of its naming class (11.2)<sup>115</sup> As described earlier, access to a protected member is granted(被准许) because the reference occurs in a friend or member of some class C. If the access is to form a pointer to member (5.3.1), the *nested-name-specifier* shall denote C or a class derived from C. All other accesses involve a (possibly implicit) object expression (5.2.5). In this case, the class of the object expression shall be C or a class derived from C.

> This additional check does not apply to other members, e.g., static data members or enumerator member constants.
> 

```
class B {
protected:
    int i;
    static int j;
};

class D1 : public B {

};

class D2 : public B {
    friend void fr(B*,D1*,D2*);
    void mem(B*,D1*);
};

void fr(B* pb, D1* p1, D2* p2) {
    pb->i = 1;      // ill-formed      fr不是类B的友元.
    p1->i = 2;      // ill-formed      fr不是类D1的友元.
    p2->i = 3;      // OK (access through a D2) fr是类D2的友元.
    p2->B::i = 4;   // OK (access through a D2, even though naming class is B)  [11.2/5]
    int B::* pmi_B = &B::i;     // ill-formed       对i的引用发生在D2的友元函数中, 所以上面的C是指D2, 所以B不是C, 也不是派生自C.
    int B::* pmi_B2 = &D2::i;   // OK (type of &D2::i is int B::*)
    B::j = 5;   // OK (because refers to static member) 这段的附加限制仅针对non-static的数据成员和non-static成员函数, static成员根据[11.2/5]是可以访问的.
    D2::j = 6;  // OK (because refers to static member)
}

void D2::mem(B* pb, D1* p1) {
  pb->i = 1;    // ill-formed
  p1->i = 2;    // ill-formed
  i = 3;        // OK (access through this)
  B::i = 4;     // OK (access through this)
  int B::* pmi_B = &B::i;   // ill-formed 对i的引用发生在D2的成元函数中, 所以上面的C是指D2, 所以B不是C, 也不是派生自C.
  int B::* pmi_B2 = &D2::i; // OK
  j = 5;        // OK (because j refers to static member)
  B::j = 6;     // OK (because B::j refers to static member)
}

void g(B* pb, D1* p1, D2* p2) { 不是友元也不是成员, 所以对B, D1, D2的non-public成员都不可访问.
    pb->i = 1;  // ill-formed
    p1->i = 2;  // ill-formed
    p2->i = 3;  // ill-formed
}
```

### 11.5 Access to virtual functions

1 The access rules (Clause 11) for a virtual function are determined by its declaration and are not affected by the rules for a function that later overrides it.

虚函数的访问规则(由*access-specifier*指定)由其声明决定, 并且不受后面覆盖它的函数规则的影响.

```
class B {
public:
    virtual int f();
};

class D : public B {
private:
    int f();    /*virtual int f();*/
};

void f() {
    D d;
    B* pb = &d;
    D* pd = &d;
    pb->f();    // OK: B::f() is public,
    pd->f();    // D::f() is invoked
                // error: D::f() is private
}
```

2 Access is checked at the call point using the type of the expression used to denote the object for which the member function is called (B* in the example above). The access of the member function in the class in which it was defined (D in the example above) is in general not known.

### 11.7 Nested classes

1 嵌套类(nested class)也是一个类成员并且因此与其他任何成员具有相同的访问权限.
封闭类(enclosing class)的成员对嵌套类的成员没有特殊的访问权限, 应该遵守通常的访问规则.

```
class E {
    int x;
    class B { };
    class I {
        B b;        // OK: E::I can access E::B
        int y;
        void f(E* p, int i) {
            p->x = i; // OK: E::I can access E::x
        }
    };

    int g(I* p) {
        return p->y;  // error: I::y is private
    }
};

```

### 12 Special member functions

1 The default constructor (12.1), copy constructor and copy assignment operator (12.8), move constructor and move assignment operator (12.8), and destructor (12.4) are *special member functions*. [Note: The implementation will implicitly declare these member functions for some class types when the program does not explicitly declare them. The implementation will implicitly define them if they are odr-used (3.2). See12.1,12.4 and 12.8. —end note] Programs shall not define implicitly-declared special member functions.

2 Programs may explicitly refer to implicitly-declared special member functions. [Example: a program may explicitly call, take the address of or form a pointer to member to an implicitly-declared special member function.

```
struct A { }; // implicitly declared A::operator=
struct B : A {
    B& operator=(const B &);
};
B& B::operator=(const B& s) {
    this->A::operator=(s);  // well formed
    return *this;
}
```

3 [Note: The special member functions affect the way objects of class type are created, copied, moved, and destroyed, and how values can be converted to values of other types. Often such special member functions are called implicitly. — end note ]

4 Special member functions obey the usual access rules (Clause 11). [Example: declaring a constructor protected ensures that only derived classes and friends can create objects using it. — end example ]

### 12.1 Constructors

1 Constructors do not have names. A special declarator syntax is used to declare or define the constructor. The syntax uses:

— an optional *decl-specifier-seq* in which each *decl-specifier* is either a *function-specifier* or **constexpr**,

— the constructor’s class name, and

— a parameter list

in that order. In such a declaration, optional parentheses around the constructor class name are ignored.

```
struct S {
   S(); // declares the constructor
};

S::S() { }  // defines the constructor
```

2 A constructor is used to initialize objects of its class type. Because constructors do not have names, they are never found during name lookup; however an explicit type conversion using the functional notation(函数表示法) (5.2.3) will cause a constructor to be called to initialize an object. [ Note: For initialization of objects of class type see12.6. —end note]

[12.1/11]

3 A *typedef-name* shall not be used as the *class-name* in the *declarator-id* for a constructor declaration.

4 A constructor shall not be **virtual** (10.3) or **static** (9.4). A constructor can be invoked for a const, volatile or const volatile object. A constructor shall not be declared **const**, **volatile**, or **const volatile** (9.3.2). **const** and **volatile** semantics (7.1.6.1) are not applied on an object under construction. They come into effect when the constructor for the most derived object (1.8) ends(它们当最派生对象构造结束时生效). A constructor shall not be declared with a ref-qualifier.

```
struct S {
   S(){
	   int x = f();    //ok
   };
   int f() {
	   return 0;
   }
private:
   int x;
};

const S s;
```

5 A *default* constructor for a class X is a constructor of class X that can be called without an argument. If there is no user-declared constructor for class X, a constructor having no parameters is implicitly declared as defaulted (8.4). An implicitly-declared default constructor is an **inline public** member of its class. A defaulted default constructor for class X is defined as deleted if:

— X is a union-like class that has a variant member with a non-trivial default constructor,

— any non-static data member with no brace-or-equal-initializer is of reference type,

— any non-variant non-static data member of const-qualified type (or array thereof) with no brace-or- equal-initializer does not have a user-provided default constructor,

— X is a union and all of its variant members are of const-qualified type (or array thereof),

— X is a non-union class and all members of any anonymous union member are of const-qualified type
(or array thereof),

— any direct or virtual base class, or non-static data member with no brace-or-equal-initializer, has class type M (or array thereof) and either M has no default constructor or overload resolution (13.3) as applied to M’s default constructor results in an ambiguity or in a function that is deleted or inaccessible from the defaulted default constructor, or

— any direct or virtual base class or non-static data member has a type with a destructor that is deleted or inaccessible from the defaulted default constructor.

A default constructor is trivial if it is not user-provided and if:

— its class has no virtual functions (10.3) and no virtual base classes (10.1), and

— no non-static data member of its class has a brace-or-equal-initializer, and

— all the direct base classes of its class have trivial default constructors, and

— for all the non-static data members of its class that are of class type (or array thereof), each such class has a trivial default constructor.

Otherwise, the default constructor is *non-trivial*.

6 A default constructor that is defaulted and not defined as deleted is *implicitly defined* when it is odr-used (3.2) to create an object of its class type (1.8) or when it is explicitly defaulted after its first declaration. The implicitly-defined default constructor performs the set of initializations of the class that would be performed by a user-written default constructor for that class with no *ctor-initializer* (12.6.2) and an empty *compound-statement*. If that user-written default constructor would be ill-formed, the program is ill-formed. If that user-written default constructor would satisfy the requirements of a constexpr constructor (7.1.5), the implicitly-defined default constructor is **constexpr**. Before the defaulted default constructor for a class is implicitly defined, all the non-user-provided default constructors for its base classes and its non-static data members shall have been implicitly defined. [Note: An implicitly-declared default constructor has an exception-specification (15.4). An explicitly-defaulted definition might have an implicit exception-specification, see 8.4. — end note ]

隐式定义(implicitly-defined)的默认构造函数执行的初始化集与用户编写(user-written)的不带有ctor-initializer并且空函数体的默认构造函数一样. ...

7 Default constructors are called implicitly to create class objects of static, thread, or automatic storage duration (3.7.1, 3.7.2, 3.7.3) defined without an initializer (8.5), are called to create class objects of dynamic storage duration (3.7.4) created by a *new-expression* in which the *new-initializer* is omitted (5.3.4), or are called when the explicit type conversion syntax (5.2.3) is used. A program is ill-formed if the default constructor for an object is implicitly used and the constructor is not accessible (Clause 11).

8 [Note: 12.6.2 describes the order in which constructors for base classes and non-static data members are called and describes how arguments can be specified for the calls to these constructors. — end note ]

9 A copy constructor (12.8) is used to copy objects of class type. A move constructor (12.8) is used to move the contents of objects of class type.

10 No return type (not even void) shall be specified for a constructor. A return statement in the body of a constructor shall not specify a return value. The address of a constructor shall not be taken.

11 A functional notation type conversion (5.2.3) can be used to create new objects of its type. [Note: The syntax looks like an explicit call of the constructor. — end note ]

```
complex zz = complex(1,2.3);
cprint( complex(7.8,1.2) );

```

12 An object created in this way is unnamed. [Note: 12.2 describes the lifetime of temporary objects. —end note ]
[ Note: Explicit constructor calls do not yield lvalues, see 3.10. — end note ]

14 During the construction of a **const** object, if the value of the object or any of its subobjects is accessed through a glvalue that is not obtained, directly or indirectly, from the constructor’s this pointer, the value of the object or subobject thus obtained is unspecified.

```
struct C;
void no_opt(C*);
struct C {
    int c;
    C() : c(0) { no_opt(this); }
};
const C cobj;
void no_opt(C* cptr) {
    int i = cobj.c * 100;    // value of cobj.c is unspecified
    cptr->c = 1;
    cout << cobj.c * 100     // value of cobj.c is unspecified
    << ’\\n’;
}
```

### 12.2 Temporary objects

1 Temporaries of class type are created in various contexts: binding a reference to a prvalue (8.5.3), returning a prvalue (6.6.3), a conversion that creates a prvalue (4.1, 5.2.9, 5.2.11, 5.4), throwing an exception (15.1), entering a handler (15.3), and in some initializations (8.5). [Note: The lifetime of exception objects is described in 15.1. — end note ] Even when(即使当) the creation of the temporary object is unevaluated (Clause 5) or otherwise avoided(被避免) (12.8), all the semantic restrictions shall be respected(被遵守) as if the temporary object had been created and later destroyed. [ Note: even if there is no call to the destructor or copy/move constructor, all the semantic restrictions, such as accessibility (Clause 11) and whether the function is deleted (8.4.3), shall be satisfied. However, in the special case of a function call used as the operand of a *decltype-specifier* (5.2.2), no temporary is introduced, so the foregoing(前述) does not apply to the prvalue of any such function call. — end note ]

2 Consider the following code:

```
class X {
public:
    X(int);
    X(const X&);
    X& operator=(const X&);
    ~X();
};
class Y {
public:
    Y(int);
    Y(Y&&);
    ~Y();
};
X f(X);
Y g(Y);
void h() {
    X a(1);
    X b = f(X(2));
    Y c = g(Y(3));
    a = f(a);
}
```

An implementation might use a temporary in which to construct X(2) before passing it to f() using X’s copy constructor; alternatively, X(2) might be constructed in the space used to hold the argument. Likewise, an implementation might use a temporary in which to construct Y(3) before passing it to g() using Y’s move constructor; alternatively, Y(3) might be constructed in the space used to hold the argument. Also, a temporary might be used to hold the result of f(X(2)) before copying it to b using X’s copy constructor; alternatively, f()’s result might be constructed in b. Likewise, a temporary might be used to hold the result of g(Y(3)) before moving it to c using Y’s move constructor; alternatively, g()’s result might be constructed in c. On the other hand, the expression `a=f(a)` requires a temporary for the result of f(a), which is then assigned to a.

3 When an implementation introduces a temporary object of a class that has a non-trivial constructor (12.1, 12.8), it shall ensure that a constructor is called for the temporary object. Similarly, the destructor shall be called for a temporary with a non-trivial destructor (12.4). Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created. This is true even if that evaluation ends in throwing an exception. The value computations and side effects of destroying a temporary object are associated only with the full-expression, not with any specific subexpression.

临时对象的销毁.

4 There are two contexts in which temporaries are destroyed at a different point than the end of the full-expression. The first context is when a default constructor is called to initialize an element of an array. If the constructor has one or more default arguments, the destruction of every temporary created in a default argument is sequenced before the construction of the next array element, if any.

5 The second context is when a reference is bound to a temporary. The temporary to which the reference is bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference except:

第二个上下文是当引用绑定到临时对象. 引用绑定的临时对象或引用绑定的子对象的完整对象是一个临时对象, 则被绑定的临时对象将持续到引用的生命周期结束, 除非:

— A temporary bound to a reference member in a constructor’s ctor-initializer (12.6.2) persists until the constructor exits.

— A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full-expression containing the call.

— The lifetime of a temporary bound to the returned value in a function return statement (6.6.3) is not extended; the temporary is destroyed at the end of the full-expression in the return statement.

— A temporary bound to a reference in a *new-initializer* (5.3.4) persists until the completion of the full-expression containing the *new-initializer*.

```
struct S { int mi; const std::pair<int,int>& mp; };
S a { 1, {2,3} };
S* p = new S{ 1, {2,3} }; // Creates dangling reference

```

[ Note: This may introduce a dangling reference, and implementations are encouraged to issue a warning in such a case. — end note ]

The destruction of a temporary whose lifetime is not extended by being bound to a reference is sequenced before the destruction of every temporary which is constructed earlier in the same full-expression. If the lifetime of two or more temporaries to which references are bound ends at the same point, these temporaries are destroyed at that point in the reverse order of the completion of their construction. In addition, the destruction of temporaries bound to references shall take into account the ordering of destruction of objects with static, thread, or automatic storage duration (3.7.1, 3.7.2, 3.7.3); that is, if obj1 is an object with the same storage duration as the temporary and created before the temporary is created the temporary shall be destroyed before obj1 is destroyed; if obj2 is an object with the same storage duration as the temporary and created after the temporary is created the temporary shall be destroyed after obj2 is destroyed.

绑定到一个引用但是生命周期没有被延长的临时对象的析构先序于早先被构造在同一个完整表达式中的每个临时对象的析构.
如果有两个或两个以上的临时对象的引用结束在同一点, 则临时对象的析构按将照它们构造时相反的顺序进行.
另外, 引用绑定的临时对象的析构应该考虑静态, 线程, 自动存储周期的析构顺序.

```
struct S {
    S();
    S(int);
    friend S operator+(const S&, const S&);
    ~S();
};
S obj1;
const S& cr = S(16)+S(23);
S obj2;
```

the expression `S(16) + S(23)` creates three temporaries: a first temporary T1 to hold the result of the expression S(16), a second temporary T2 to hold the result of the expression S(23), and a third temporary T3 to hold the result of the addition of these two expressions. The temporary T3 is then bound to the reference cr. It is unspecified whether T1 or T2 is created first. On an implementation where T1 is created before T2, it is guaranteed(保证) that T2 is destroyed before T1. The temporaries T1 and T2 are bound to the reference parameters of **operator+**; these temporaries are destroyed at the end of the full-expression containing the call to **operator+**. The temporary T3 bound to the reference cr is destroyed at the end of cr’s lifetime, that is, at the end of the program. In addition, the order in which T3 is destroyed takes into account the destruction order of other objects with static storage duration. That is, because obj1 is constructed before T3, and T3 is constructed before obj2, it is guaranteed that obj2 is destroyed before T3, and that T3 is destroyed before obj1. — end example ]

### 12.3 Conversions

1 Type conversions of class objects can be specified by constructors and by conversion functions. These conversions are called *user-defined conversions* and are used for implicit type conversions (Clause 4), for initialization (8.5), and for explicit type conversions (5.4, 5.2.9).

2 User-defined conversions are applied only where they are unambiguous (10.2, 12.3.2). Conversions obey the access control rules (Clause 11). Access control is applied after ambiguity resolution (3.4).

4 At most one user-defined conversion (constructor or conversion function) is implicitly applied to a single value.

```
struct X {
    operator int();
};
struct Y {
    operator X();
};
Y a;
int b=a;    // error
            // a.operator X().operator int() not tried
int c = X(a);   // OK: a.operator X().operator int()
```

5 User-defined conversions are used implicitly only if they are unambiguous. A conversion function in a derived class does not hide a conversion function in a base class unless the two functions convert to the same type. Function overload resolution (13.3.3) selects the best conversion function to perform the conversion.

```
struct X {
    operator int();
};
  struct Y : X {
      operator char();
};
  void f(Y& a) {
    if (a) {    // ill-formed:
                // X::operator int() or Y::operator char()
    }
}
```

### 12.3.1 Conversion by constructor

1 A constructor declared without the *function-specifier* **explicit** specifies a conversion from the types of its parameters to the type of its class. Such a constructor is called a *converting constructor*.

```
struct X {
    X(int);
    X(const char*, int =0);
};
void f(X arg) {
    X a = 1;        // a = X(1)
    X b = "Jessie"; // b = X("Jessie",0)
    a = 2;          // a = X(2)
    f(3);           // f(X(3))
}
```

2 An explicit constructor constructs objects just like non-explicit constructors, but does so only where the direct-initialization syntax (8.5) or where casts (5.2.9, 5.4) are explicitly used. A default constructor may be an explicit constructor; such a constructor will be used to perform default-initialization or value-initialization (8.5).

一个显式构造函数构造对象就想非显式构造函数, 但这仅在直接初始化语法或者显式转换被使用的地方.

```
struct Z {
    explicit Z();
    explicit Z(int);
};
Z a;            // OK: default-initialization performed
Z a1 =1;        // error: no implicit conversion
Z a3 = Z(1);    // OK: direct initialization syntax used
Z a2(1);        // OK: direct initialization syntax used
Z* p = new Z(1); // OK: direct initialization syntax used
Z a4 = (Z)1;     // OK: explicit cast used
Z a5 = static_cast<Z>(1);   // OK: explicit cast used
```

3 A non-explicit copy/move constructor (12.8) is a converting constructor. An implicitly-declared copy/move
constructor is not an explicit constructor; it may be called for implicit type conversions.

### 12.3.2 Conversion functions

1 A member function of a class X having no parameters with a name of the form

*conversion-function-id:
    operator conversion-type-id
conversion-type-id:
    type-specifier-seq conversion-declaratoropt
conversion-declarator:
    ptr-operator conversion-declaratoropt*

specifies a conversion from X to the type specified by the *conversion-type-id*. Such functions are called conversion functions. No return type can be specified. If a conversion function is a member function, the type of the conversion function (8.3.5) is “function taking no parameter returning conversion-type-id”. A conversion function is never used to convert a (possibly cv-qualified) object to the (possibly cv-qualified) same object type (or a reference to it), to a (possibly cv-qualified) base class of that type (or a reference to it), or to (possibly cv-qualified) void.116

```
struct X {
    operator int();
};
void f(X a) {
    int i = int(a);
    i = (int)a;
    i = a;
}
```

In all three cases the value assigned will be converted by X::operator int().

2 A conversion function may be explicit (7.1.2), in which case it is only considered as a user-defined conversion for direct-initialization (8.5). Otherwise, user-defined conversions are not restricted to use in assignments and initializations.

```
class Y { };
struct Z {
    explicit operator Y() const;
};
void h(Z z) {
    Y y1(z);        // OK: direct-initialization
    Y y2 = z;       // ill-formed: copy-initialization
    Y y3 = (Y)z;    // OK: cast notation
}

void g(X a, X b) {
    int i = (a) ? 1+a : 0;
    int j = (a&&b) ? a+b : i;
    if (a) {

    }
}
```

3 The *conversion-type-id* shall not represent a function type nor an array type. The *conversion-type-id* in a *conversion-function-id* is the longest possible sequence of *conversion-declarators*. [Note: This prevents(防止) ambiguities between the declarator operator * and its expression counterparts.

```
&ac.operator int*i; // syntax error:
                    // parsed as: &(ac.operator int *)i
                    // not as: &(ac.operator int)*i
```

The * is the pointer declarator and not the multiplication operator. — end note ]

4 Conversion functions are inherited.

5 Conversion functions can be virtual.

6 Conversion functions cannot be declared **static**.

### 12.4 Destructors

1 A special declarator syntax using an optional *function-specifier* (7.1.2) followed by  ̃ followed by the destructor’s class name followed by an empty parameter list is used to declare the destructor in a class definition. In such a declaration, the  ̃ followed by the destructor’s class name can be enclosed in optional parentheses; such parentheses are ignored. A *typedef-name* shall not be used as the *class-name* following the ∼ in the declarator for a destructor declaration.

2 A destructor is used to destroy objects of its class type. A destructor takes no parameters, and no return type can be specified for it (not even void). The address of a destructor shall not be taken. A destructor shall not be static. A destructor can be invoked for a const, volatile or const volatile object. A destructor shall not be declared const, volatile or const volatile (9.3.2). const and volatile semantics (7.1.6.1) are not applied on an object under destruction. They stop being in effect when the destructor for the most derived object (1.8) starts(它们当最派生对象的析构函数开始时停止生效). A destructor shall not be declared with a *ref-qualifier*.

3 A declaration of a destructor that does not have an *exception-specification* is implicitly considered to have the same *exception-specification* as an implicit declaration (15.4).

4 If a class has no user-declared destructor, a destructor is implicitly declared as defaulted (8.4). An implicitly-declared destructor is an inline public member of its class.

5 A defaulted destructor for a class X is defined as deleted if:

— X is a union-like class that has a variant member with a non-trivial destructor,

— any of the non-static data members has class type M (or array thereof) and M has a deleted destructor or a destructor that is inaccessible from the defaulted destructor,

— any direct or virtual base class has a deleted destructor or a destructor that is inaccessible from the defaulted destructor,

— or, for a virtual destructor, lookup of the non-array deallocation function results in an ambiguity or in a function that is deleted or inaccessible from the defaulted destructor.

A destructor is trivial if it is not user-provided and if:

— the destructor is not virtual,

— all of the direct base classes of its class have trivial destructors, and

— for all of the non-static data members of its class that are of class type (or array thereof), each such class has a trivial destructor.

Otherwise, the destructor is non-trivial.

6 A destructor that is defaulted and not defined as deleted is *implicitly defined* when it is odr-used (3.2) to
destroy an object of its class type (3.7) or when it is explicitly defaulted after its first declaration.

7 Before the defaulted destructor for a class is implicitly defined, all the non-user-provided destructors for its
base classes and its non-static data members shall have been implicitly defined.

8 After executing the body of the destructor and destroying any automatic objects allocated within the body, a destructor for class X calls the destructors for X’s direct non-variant non-static data members, the destructors for X’s direct base classes and, if X is the type of the most derived class (12.6.2), its destructor calls the destructors for X’s virtual base classes. All destructors are called as if they were referenced with a qualified name, that is, ignoring any possible virtual overriding destructors in more derived classes. Bases and members are destroyed in the reverse order of the completion of their constructor (see 12.6.2). A return statement (6.6.3) in a destructor might not directly return to the caller; before transferring control to the caller, the destructors for the members and bases are called. Destructors for elements of an array are called in reverse order of their construction (see 12.6).

析构函数调用顺序(被销毁的对象静态类型为X):
当类X的构造函数的函数体被调用之后, 首先销毁函数体内分配的的所有自动存储周期的对象,
之后为类X的直接非变量非静态数据成员调用析构函数,
之后为类X的直接基类调用析构函数,
之后如果X是最派生类, 则为类X的虚基类调用调用构造函数.
每个基类和成员都会以构造相反的顺序销毁.

9 A destructor can be declared **virtual** (10.3) or pure **virtual** (10.4); if any objects of that class or any derived class are created in the program, the destructor shall be defined. If a class has a base class with a virtual destructor, its destructor (whether user- or implicitly- declared) is virtual.

这意味着当对基类指针指向的派生类对象调用析构函数时, 对虚析构函数调用将被解释为派生类对象的析构函数[10.3/9], 之后根据[12.4/8]调用其它的析构函数.

参考 [5.3.5/3], [12.5/7]

```
struct B
{
	virtual ~B(){
		std::cout << "B::~B()" << std::endl;
	}
};

struct D : public B
{
	~D(){
		std::cout << "D::~D()" << std::endl;
	}
};

void f(){
	B* p = new D();
	delete p;      //ok, 先调用B::~B(), 在调用D::~D();
}

struct B1
{
	virtual ~B(){
		std::cout << "B1::~B1()" << std::endl;
	}
};

struct D1 : public B1
{
	~D(){
		std::cout << "D1::~D1()" << std::endl;
	}
private:
    void* p = /*...*/
};

void g(){
	B1* p = new D1();
	delete p;      //ERROR, 仅调用B1::~B1();
}
```

11 Destructors are invoked implicitly

— for constructed objects with static storage duration (3.7.1) at program termination (3.6.3),

— for constructed objects with thread storage duration (3.7.2) at thread exit,

— for constructed objects with automatic storage duration (3.7.3) when the block in which an object is created exits (6.7),

— for constructed temporary objects when the lifetime of a temporary object ends (12.2),

— for constructed objects allocated by a new-expression (5.3.4), through use of a delete-expression (5.3.5),

— in several situations due to the handling of exceptions (15.3).

A program is ill-formed if an object of class type or array thereof is declared and the destructor for the class
is not accessible at the point of the declaration. Destructors can also be invoked explicitly.

12 At the point of definition of a virtual destructor (including an implicit definition (12.8)), the non-array deallocation function is looked up in the scope of the destructor’s class (10.2), and, if no declaration is found, the function is looked up in the global scope. If the result of this lookup is ambiguous or inaccessible, or if the lookup selects a placement deallocation function or a function with a deleted definition (8.4), the program is ill-formed. [ Note: This assures that a deallocation function corresponding to the dynamic type of an object is available for the delete-expression (12.5). — end note ]

对应 [12.5/4]

13 In an explicit destructor call, the destructor name appears as a  ̃ followed by a *type-name* or *decltype-specifier* that denotes the destructor’s class type. The invocation of a destructor is subject to the usual rules for member functions (9.3), that is, if the object is not of the destructor’s class type and not of a class derived from the destructor’s class type, the program has undefined behavior (except that invoking delete on a null pointer has no effect).

```
struct B {
    virtual ~B() { }
};

struct D : B {
    ~D() { }
};

D D_object;
typedef B B_alias;
B* B_ptr = &D_object;

void f() {
    D_object.B::~B();           // calls B’s destructor [11.2/5]
    B_ptr->~B();                // calls D’s destructor
    B_ptr->~B_alias();          // calls D’s destructor
    B_ptr->B_alias::~B();       // calls B’s destructor [11.2/5]
    B_ptr->B_alias::~B_alias(); // calls B’s destructor [11.2/5]
}
```

[ Note: An explicit destructor call must always be written using a member access operator (5.2.5) or a qualified-id (5.1); in particular, the unary-expression ~**X()** in a member function is not an explicit destructor call (5.3.1). — end note ]

14 [Note: explicit calls of destructors are rarely needed. One use of such calls is for objects placed at specific addresses using a *new-expression* with the placement option. Such use of explicit placement and destruction of objects can be necessary to cope with dedicated(专用的) hardware resources and for writing memory management facilities(设施). For example,

```
void* operator new(std::size_t, void* p) { return p; }
struct X {
    X(int);
    ~X();
};
void f(X* p);
void g() {                          //rare, specialized use:
    char* buf = new char[sizeof(X)];
    X* p = new(buf) X(222);         // use buf[] and initialize f(p);
    p->X::~X();                     // cleanup
}
```

15 Once a destructor is invoked for an object, the object no longer exists; the behavior is undefined if the destructor is invoked for an object whose lifetime has ended (3.8). [Example: if the destructor for an automatic object is explicitly invoked, and the block is subsequently left in a manner that would ordinarily invoke implicit destruction of the object, the behavior is undefined. — end example ]

如果析构函数为一个自动存储周期的对象显式地调用, 并且离开块作用域时会隐式地调用对象的析构函数, 则将导致未定义行为.

16 [ Note: the notation for explicit call of a destructor can be used for any scalar type name (5.2.4). Allowing this makes it possible to write code without having to know if a destructor exists for a given type. For example,

```
typedef int I;
I* p;
p->I::~I();
```

参考[5.2.4]

### 12.5 Free store

1 Any allocation function for a class T is a **static** member (even if not explicitly declared **static**).

2

```cpp
class Arena;
struct B {
	void* operator new(std::size_t, Arena*);
};
struct D1 : B {
};
Arena*  ap;
void foo(int i) {
new (ap) D1;    // calls B::operator new(std::size_t, Arena*) 这个函数会被继承到D1, 即使它是静态的[10/2].
new D1[i];      // calls ::operator new
new D1;         // ill-formed: ::operator new(std::size_t) hidden 名称查找发现D中的分配函数并且停止查找, 但是被发现的内存分配函数不匹配new D1所需要使用的形式.
}
```

3 When an object is deleted with a *delete-expression* (5.3.5), a deallocation function (operator delete() for non-array objects or **operator delete[]()** for arrays) is (implicitly) called to reclaim(回收) the storage occupied by the object (3.7.4.2).

4 If a *delete-expression* begins with a unary :: operator, the deallocation function’s name is looked up in global scope. Otherwise, if the *delete-expression* is used to deallocate a class object whose static type has a virtual destructor, the deallocation function is the one selected at the point of definition of the dynamic type’s virtual destructor (12.4).117 Otherwise, if the *delete-expression* is used to deallocate an object of class T or array thereof, the static and dynamic types of the object shall be identical(相同的) and the deallocation function’s name is looked up in the scope of T. If this lookup fails to find the name, the name is looked up in the global scope. If the result of the lookup is ambiguous or inaccessible, or if the lookup selects a placement deallocation function, the program is ill-formed.

5 When a *delete-expression* is executed, the selected deallocation function shall be called with the address of the block of storage to be reclaimed as its first argument and (if the two-parameter style is used) the size of the block as its second argument.<sup>118</sup>
>118) If the static type of the object to be deleted is different from the dynamic type and the destructor is not virtual the size might be incorrect, but that case is already undefined; see 5.3.5. [5.3.5/3]

6 Any deallocation function for a class X is a **static** member (even if not explicitly declared **static**)

```cpp
class X {
    void operator delete(void*);
    void operator delete[](void*, std::size_t);
};
class Y {
    void operator delete(void*, std::size_t);
    void operator delete[](void*);
};
```

7 Since member allocation and deallocation functions are **static** they cannot be virtual. [Note: however, when the cast-expression of a delete-expression refers to an object of class type, because the deallocation function actually called is looked up in the scope of the class that is the dynamic type of the object, if the destructor is virtual, the effect is the same. For example,

内存销毁函数根据对象的动态类型调用

```
struct B {
    virtual ~B();
    void operator delete(void*, std::size_t);
};
struct D : B {
    void operator delete(void*);
};
void f() {
    B* bp = new D;
    delete bp;  //1: uses D::operator delete(void*)
}
```

Here, storage for the non-array object of class D is deallocated by **D::operator delete()**, due to the virtual destructor. — end note ] [12.4/9]

[ Note: Virtual destructors have no effect on the deallocation function actually called when the *cast-expression* of a *delete-expression* refers to an array of objects of class type. For example,

不要以多态类型对象构建数组.

```
struct B {
    virtual ~B();
    void operator delete[](void*, std::size_t);
};
struct D : B {
    void operator delete[](void*, std::size_t);
};
void f(int i) {
    D* dp = new D[i];
    delete [] dp;       // uses D::operator delete[](void*, std::size_t)
    B* bp = new D[i];
    delete[] bp;        // undefined behavior           gcc 5.1 将会使用B::operator delete[](void*, std::size_t), 这导致所有的D对象元素都不会被释放.
}
```

8 Access to the deallocation function is checked statically. Hence, even though a different one might actually be executed, the statically visible deallocation function is required to be accessible. [ Example: for the call on line //1 above, if B::operator delete() had been private, the delete expression would have been ill-formed. —endexample]

9 [Note: If a deallocation function has no explicit *exception-specification*, it is treated as if it were specified with **noexcept(true)** (15.4). — end note ]

### 12.6 Initialization

1 When no initializer is specified for an object of (possibly cv-qualified) class type (or array thereof), or the initializer has the form (), the object is initialized as specified in 8.5.

2 An object of class type (or array thereof) can be explicitly initialized; see 12.6.1 and 12.6.2.

3 When an array of class objects is initialized (either explicitly or implicitly) and the elements are initialized by constructor, the constructor shall be called for each element of the array, following the subscript order; see 8.3.4. [ Note: Destructors for the array elements are called in reverse order of their construction. — end note ]

### 12.6.1 Explicit initialization

1 An object of class type can be initialized with a parenthesized expression-list, where the *expression-list* is construed as an argument list for a constructor that is called to initialize the object. Alternatively, a single *assignment-expression* can be specified as an *initializer* using the = form of initialization. Either direct-initialization semantics or copy-initialization semantics apply; see 8.5.

```
struct complex {
  complex();
  complex(double);
  complex(double,double);
};

complex sqrt(complex,complex);

complex a(1);                   // initialize by a call of complex(double)          //direct-initialization.

complex b = a;                  // initialize by a copy of a                        //copy-initialization

complex c = complex(1,2);       // construct complex(1,2) using complex(double,double) copy/move it into c

complex d = sqrt(b,c);          // call sqrt(complex,complex) and copy/move the result into d

complex e;                      // initialize by a call of complex()                //default-initialized

complex f = 3;                  // construct complex(3) using complex(double) copy/move it into f

complex g = { 1, 2 };           // construct complex(1, 2) using complex(double, double) and copy/move it into g

complex h(a);                   // direct-initialization.
```

[ Note: overloading of the assignment operator (13.5.3) has no effect on initialization. — end note ]

2 An object of class type can also be initialized by a *braced-init-list*. List-initialization semantics apply; see 8.5 and 8.5.4.

```
complex v[6] = { 1, complex(1,2), complex(), 2 };
```

Here, **complex::complex(double)** is called for the initialization of v[0] and v[3], **complex::complex( double, double)** is called for the initialization of v[1], **complex::complex()** is called for the initialization v[2], v[4], and v[5]. For another example,

```
struct X {
    int i;
    float f;
    complex c;
} x = { 99, 88.8, 77.7 };
```

Here, x.i is initialized with 99, x.f is initialized with 88.8, and complex::complex(double) is called for the initialization of x.c. — end example ] [ Note: Braces can be elided in the initializer-list for any aggregate, even if the aggregate has members of a class type with user-defined type conversions; see 8.5.1. — end note ]

3 [Note: If T is a class type with no default constructor, any declaration of an object of type T (or array thereof) is ill-formed if no initializer is explicitly specified (see 12.6 and 8.5). — end note ]

4 [Note: the order in which objects with static or thread storage duration are initialized is described in 3.6.2 and 6.7. —end note]

### 12.6.2 Initializing bases and members

1 In the definition of a constructor for a class, initializers for direct and virtual base subobjects and non-static data members can be specified by a ctor-initializer, which has the form

*ctor-initializer:
    : mem-initializer-list

mem-initializer-list:
    mem-initializer ...opt
    mem-initializer , mem-initializer-list ...opt

mem-initializer:
    mem-initializer-id ( expression-listopt )
    mem-initializer-id braced-init-list

mem-initializer-id:
    class-or-decltype
    identifier*

2 In a *mem-initializer-id* an initial unqualified identifier is looked up in the scope of the constructor’s class and, if not found in that scope, it is looked up in the scope containing the constructor’s definition. [ Note: If the constructor’s class contains a member with the same name as a direct or virtual base class of the class, a *mem-initializer-id* naming the member or base class and composed of a single identifier refers to the class member. A *mem-initializer-id* for the hidden base class may be specified using a qualified name. — end note ] Unless the *mem-initializer-id* names the constructor’s class, a non-static data member of the constructor’s class, or a direct or virtual base of that class, the mem-initializer is ill-formed.

3 A *mem-initializer-list* can initialize a base class using any *class-or-decltype* that denotes that base class type.

```
struct A { A(); };
typedef A global_A;
struct B { };
struct C: public A, public B { C(); };
C::C(): global_A() { } // mem-initializer for base A
```

4 If a *mem-initializer-id* is ambiguous because it designates both a direct non-virtual base class and an inherited virtual base class, the *mem-initializer* is ill-formed.

```
struct A { A(); };
struct B: public virtual A { };
struct C: public A, public B { C(); };
C::C(): A() { } // ill-formed: which A?
```

5 A *ctor-initializer* may initialize a variant member of the constructor’s class. If a *ctor-initializer* specifies more than one *mem-initializer* for the same member or for the same base class, the ctor-initializer is ill-formed.

6 A *mem-initializer-list* can delegate to another constructor of the constructor’s class using any *class-or-decltype* that denotes the constructor’s class itself. If a *mem-initializer-id* designates the constructor’s class, it shall be the only *mem-initializer*; the constructor is a *delegating constructor*, and the constructor selected by the *mem-initializer* is the *target constructor*. The *principal(主要的) constructor* is the first constructor invoked in the construction of an object (that is, not a target constructor for that object’s construction). The target constructor is selected by overload resolution. Once the target constructor returns, the body of the delegating constructor is executed. If a constructor delegates to itself directly or indirectly, the program is ill-formed; no diagnostic is required.

```
struct C {
  C( int ) { }                  // #1: non-delegating constructor
  C(): C(42) { }                // #2: delegates to #1
  C( char c ) : C(42.0) { }     // #3: ill-formed due to recursion with #4
  C( double d ) : C(’a’) { }    // #4: ill-formed due to recursion with #3
};
```

7 The *expression-list* or *braced-init-list* in a *mem-initializer* is used to initialize the designated subobject (or, in the case of a delegating constructor, the complete class object) according to the initialization rules of 8.5 for direct-initialization.

```
struct B1 { B1(int); /∗ ... ∗/ };
struct B2 { B2(int); /∗ ... ∗/ };
struct D : B1, B2 {
       D(int);
       B1 b;
       const int c;
};
D::D(int a) : B2(a+1), B1(a+2), c(a+3), b(a+4) { /∗ ... ∗/ }
D d(10);
```

The initialization performed by each *mem-initializer* constitutes a full-expression. Any expression in a *mem-initializer* is evaluated as part of the full-expression that performs the initialization. A *mem-initializer* where the *mem-initializer-id* denotes a virtual base class is ignored during execution of a constructor of any class that is not the most derived class.

8 In a non-delegating constructor, if a given non-static data member or base class is not designated by a *mem-initializer-id* (including the case where there is no *mem-initializer-list* because the constructor has no *ctor-initializer*) and the entity is not a virtual base class of an abstract class (10.4), then

— if the entity is a non-static data member that has a *brace-or-equal-initializer*, the entity is initialized as specified in 8.5;

— otherwise, if the entity is a variant member (9.5), no initialization is performed;

— otherwise, the entity is *default-initialized* (8.5).

[ Note: An abstract class (10.4) is never a most derived class, thus its constructors never initialize virtual
base classes, therefore the corresponding mem-initializer s may be omitted. — end note ] An attempt to initialize more than one non-static data member of a union renders the program ill-formed. After the call to a constructor for class X has completed, if a member of X is neither initialized nor given a value during execution of the compound-statement of the body of the constructor, the member has indeterminate value.

```
struct A {
    A();
};
struct B {
  B(int);
};
struct C {
    C() { }     // initializes members as follows:
    A a;        // OK: calls A::A()
    const B b;  // error: B has no default constructor
    int i;      // OK: i has indeterminate value
    int j = 5;  // OK: j has the value 5
};
```

9 If a given non-static data member has both a *brace-or-equal-initializer* and a *mem-initializer*, the initialization specified by the *mem-initializer* is performed, and the non-static data member’s *brace-or-equal-initializer* is ignored. [ Example: Given

```
struct A {
    int i = /∗ some integer expression with side effects ∗/ ;
    A(int arg) : i(arg) { }
    // ...
};
```

the A(int) constructor will simply initialize i to the value of arg, and the side effects in i’s *brace-or-equal-initializer* will not take place. — end example ]

10 In a non-delegating constructor, initialization proceeds in the following order:

— First, and only for the constructor of the most derived class (1.8), virtual base classes are initialized in the order they appear on a depth-first left-to-right traversal of the directed

acyclic graph of base classes, where “left-to-right” is the order of appearance of the base classes in the derived class *base-specifier-list*.

— Then, direct base classes are initialized in declaration order as they appear in the *base-specifier-list* (regardless of the order of the *mem-initializers*).

— Then, non-static data members are initialized in the order they were declared in the class definition (again regardless of the order of the *mem-initializers*).

— Finally, the *compound-statement* of the constructor body is executed.

[Note: The declaration order is mandated to ensure that base and member subobjects are destroyed in the reverse order of initialization. — end note ]

```
struct V {
    V();
    V(int);
};

struct A : virtual V {
    A();
    A(int);
};

struct B : virtual V {
    B();
    B(int);
};

struct C : A, B, virtual V {
    C();
    C(int);
};

A::A(int i) : V(i) { /∗ ... ∗/ }
B::B(int i) { /∗ ... ∗/ }
C::C(int i) { /∗ ... ∗/ }

V v(1); // use V(int)
A a(2); // use V(int)
B b(3); // use V()
C c(4); // use V()
```

12 Names in the *expression-list* or *braced-init-list* of a *mem-initializer* are evaluated in the scope of the constructor for which the *mem-initializer* is specified.

```
class X {
    int a;
    int b;
    int i;
    int j;
    public:
    const int& r;
    X(int i): r(a), b(i), i(i), j(this->i) { }
};
```

initializes X::r to refer to X::a, initializes X::b with the value of the constructor parameter i, initializes X::i with the value of the constructor parameter i, and initializes X::j with the value of X::i; this takes place each time an object of class X is created. — end example ] [ Note: Because the mem-initializer are evaluated in the scope of the constructor, the **this** pointer can be used in the *expression-list* of a *mem-initializer* to refer to the object being initialized. — end note ]

13 Member functions (including virtual member functions, 10.3) can be called for an object under construction. Similarly, an object under construction can be the operand of the **typeid** operator (5.2.8) or of a **dynamic_cast** (5.2.7). However, if these operations are performed in a *ctor-initializer* (or in a function called directly or indirectly from a ctor-initializer) before all the *mem-initializers* for base classes have completed, the result of the operation is undefined.

```
class A {
public:
A(int); };
class B : public A {
  int j;
public:
  int f();
  B() : A(f()),     // undefined: calls member function but base A not yet initialized
        j(f()) { }  // well-defined: bases are all initialized
};

class C {
public:
    C(int);
};
class D : public B, C {
    int i;
public:
    D() : C(f()), // undefined: calls member function but base C not yet initialized
    i(f()) { }  // well-defined: bases are all initialized
};
```

14 [ Note: 12.7 describes the result of virtual function calls, typeid and dynamic_casts during construction for the well-defined cases; that is, describes the polymorphic behavior of an object under construction. —end note ]

15 A *mem-initializer* followed by an ellipsis is a pack expansion (14.5.3) that initializes the base classes specified by a pack expansion in the *base-specifier-list* for the class.

```
template<class... Mixins>
class X : public Mixins... {
public:
    X(const Mixins&... mixins) : Mixins(mixins)... { }
};
```

### 12.7 Construction and destruction

### 12.8 Copying and moving class objects

1 A class object can be copied or moved in two ways: by initialization (12.1, 8.5), including for function argument passing (5.2.2) and for function value return (6.6.3); and by assignment (5.17). Conceptually, these two operations are implemented by a copy/move constructor (12.1) and copy/move assignment operator (13.5.3).

2 A non-template constructor for class X is a copy constructor if its first parameter is of type **X&**, **const X&**, **olatile X&** or **const volatile X&**, and either there are no other parameters or else all other parameters have default arguments (8.3.6). [ Example: X::X(const X&) and X::X(X&,int=1) are copy constructors.

```
struct X {
    X(int);
    X(const X&, int = 1);
};
X a(1);         // calls X(int);
X b(a, 0);      // calls X(const X&, int);
X c = b;        // calls X(const X&, int);
```

3 A non-template constructor for class X is a move constructor if its first parameter is of type **X&&**, **const X&&**, **volatile X&&**, or **const volatile X&&**, and either there are no other parameters or else all other parameters have default arguments (8.3.6). [ Example: Y::Y(Y&&) is a move constructor.

```
struct Y {
    Y(const Y&);
    Y(Y&&);
};
extern Y f(int);
Y d(f(1));  // calls Y(Y&&)
Y e = d;    // calls Y(const Y&)
```

4 [ Note: All forms of copy/move constructor may be declared for a class.

```cpp
struct X {
    X(const X&);
    X(X&);          // OK
    X(X&&);
    X(const X&&);   // OK, but possibly not sensible
};
```

5 [ Note: If a class X only has a copy constructor with a parameter of type **X&**, an initializer of type **const X** or **volatile X** cannot initialize an object of type (possibly cv-qualified) X.

```cpp
struct X {
    X();    // default constructor
    X(X&);  // copy constructor with a nonconst parameter
};

const X cx;
X x = cx;   // error: X::X(X&) cannot copy cx into x
```

6 A declaration of a constructor for a class X is ill-formed if its first parameter is of type (optionally cv-qualified) X and either there are no other parameters or else all other parameters have default arguments. A member function template is never instantiated to produce such a constructor signature.

```cpp
struct S {
    template<typename T> S(T);
    S();
};

S g;

void h() {
    S a(g); // does not instantiate the member template to produce S::S<S>(S);
            // uses the implicitly declared copy constructor
}

struct C{
    template<typename T> C(T&);
    C();
};

C c;
void g(){
    C b(c);     //OK, 实例化 C::C<C>(C&);
}
```

这个限制是因为如果拷贝构造函数的形参类型为(optionally cv-qualified)X, 那么当拷贝构造函数被隐式调用时, 实参到形参的传递是也是拷贝构造, 这会递归的调用拷贝构造函数.

7 If the class definition does not explicitly declare a copy constructor, one is declared implicitly. If the class definition declares a move constructor or move assignment operator, the implicitly declared copy constructor is defined as deleted; otherwise, it is defined as defaulted (8.4). The latter case is deprecated(被废弃) if the class has a user-declared copy assignment operator or a user-declared destructor. Thus, for the class definition

```
struct X {
    X(const X&, int);   //根据[12.8/2], 这并不是拷贝构造函数, 所以仍然可以存在一个隐式声明的拷贝构造函数.
};
```

a copy constructor is implicitly-declared. If the user-declared constructor is later defined as

```
X::X(const X& x, int i =0) { /∗ ... ∗/ }    //这是一个拷贝构造函数, 所以拷贝构造函数不会被隐式声明.
```

then any use of X’s copy constructor is ill-formed because of the ambiguity; no diagnostic is required.

如果类定义没有显式声明拷贝构造函数但显式声明了移动构造函数或移动赋值操作符, 则拷贝构造函数被隐式声明为delete;
如果类定义没有显式声明拷贝构造函数也没有显式声明移动构造函数或移动赋值操作符, 则拷贝构造函数被隐式声明为default;
如果类定义中有用户声明的拷贝构造函数或拷贝赋值操作符, 则拷贝构造函数不会被隐式生成.

8 The implicitly-declared copy constructor for a class X will have the form `X::X(const X&)`

if

— each direct or virtual base class B of X has a copy constructor whose first parameter is of type **const B&** or **const volatile B&**, and

— for all the non-static data members of X that are of a class type M (or array thereof), each such class type has a copy constructor whose first parameter is of type **const M&** or **const volatile M&**.<sup>119</sup>
Otherwise, the implicitly-declared copy constructor will have the form `X::X(X&)`

9 If the definition of a class X does not explicitly declare a move constructor, one will be implicitly declared as defaulted if and only if

— X does not have a user-declared copy constructor,

— X does not have a user-declared copy assignment operator,

— X does not have a user-declared move assignment operator,

— X does not have a user-declared destructor, and

— the move constructor would not be implicitly defined as deleted.

[ Note: When the move constructor is not implicitly declared or explicitly supplied, expressions that otherwise would have invoked the move constructor may instead invoke a copy constructor. — end note ]

10 The implicitly-declared move constructor for class X will have the form `X::X(X&&)`
11 An implicitly-declared copy/move constructor is an inline public member of its class. A defaulted copy/ move constructor for a class X is defined as deleted (8.4.3) if X has:

— a variant member with a non-trivial corresponding constructor and X is a union-like class,

— a non-static data member of class type M (or array thereof) that cannot be copied/moved because overload resolution (13.3), as applied to M’s corresponding constructor, results in an ambiguity or a function that is deleted or inaccessible from the defaulted constructor,

— a direct or virtual base class B that cannot be copied/moved because overload resolution (13.3), as applied to B’s corresponding constructor, results in an ambiguity or a function that is deleted or inaccessible from the defaulted constructor,

— any direct or virtual base class or non-static data member of a type with a destructor that is deleted or inaccessible from the defaulted constructor,

— for the copy constructor, a non-static data member of rvalue reference type, or

— for the move constructor, a non-static data member or direct or virtual base class with a type that does not have a move constructor and is not trivially copyable.

12 A copy/move constructor for class X is trivial if it is not user-provided and if

— class X has no virtual functions (10.3) and no virtual base classes (10.1), and

— the constructor selected to copy/move each direct base class subobject is trivial, and

— for each non-static data member of X that is of class type (or array thereof), the constructor selected to copy/move that member is trivial;

otherwise the copy/move constructor is non-trivial.

13 A copy/move constructor that is defaulted and not defined as deleted is *implicitly defined* if it is odr-used (3.2) to initialize an object of its class type from a copy of an object of its class type or of a class type derived from its class type<sup>120</sup> or when it is explicitly defaulted after its first declaration. [Note: The copy/move constructor is implicitly defined even if the implementation elided its odr-use (3.2, 12.2). — end note ] If the implicitly-defined constructor would satisfy the requirements of a constexpr constructor (7.1.5), the implicitly-defined constructor is **constexpr**.

14 Before the defaulted copy/move constructor for a class is implicitly defined, all non-user-provided copy/move constructors for its direct and virtual base classes and its non-static data members shall have been implicitly defined. [ Note: An implicitly-declared copy/move constructor has an *exception-specification* (15.4). — end note ]

15 The implicitly-defined copy/move constructor for a non-union class X performs a memberwise copy/move of its bases and members. [Note: *brace-or-equal-initializers* of non-static data members are ignored. See also the example in 12.6.2. — end note ] The order of initialization is the same as the order of initialization of bases and members in a user-defined constructor (see 12.6.2). Let x be either the parameter of the constructor or, for the move constructor, an xvalue referring to the parameter. Each base or non-static data member is copied/moved in the manner appropriate to its type:

— if the member is an array, each element is direct-initialized with the corresponding subobject of x;

— if a member m has rvalue reference type T&&, it is direct-initialized with static_cast<T&&>(x.m);

— otherwise, the base or member is direct-initialized with the corresponding base or member of x.

Virtual base class subobjects shall be initialized only once by the implicitly-defined copy/move constructor (see 12.6.2).

16 The implicitly-defined copy/move constructor for a union X copies the object representation (3.9) of X.

17 A user-declared copy assignment operator **X::operator=** is a non-static non-template member function of class X with exactly one parameter of type **X**, **X&**, **const X&**, **volatile X&** or **const volatile X&**.121 [ Note: An overloaded assignment operator must be declared to have only one parameter; see 13.5.3. — end note ] [ Note: More than one form of copy assignment operator may be declared for a class. — end note ] [ Note: If a class X only has a copy assignment operator with a parameter of type X&, an expression of type const X cannot be assigned to an object of type X.

```
struct X {
    X();
    X& operator=(X&);
};
const X cx;
X x;
void f() {
    x = cx; // error: X::operator=(X&) cannot assign cx into x
}
```

— end note ]

18 If the class definition does not explicitly declare a copy assignment operator, one is declared implicitly. If the class definition declares a move constructor or move assignment operator, the implicitly declared copy assignment operator is defined as deleted; otherwise, it is defined as defaulted (8.4). The latter case is deprecated if the class has a user-declared copy constructor or a user-declared destructor. The implicitly-declared copy assignment operator for a class X will have the form `X& X::operator=(const X&)`

if

— each direct base class B of X has a copy assignment operator whose parameter is of type **const B&**,
**const volatile B&** or **B**, and

— for all the non-static data members of X that are of a class type M (or array thereof), each such class
type has a copy assignment operator whose parameter is of type **const M&**, **const volatile M&** or **M**.122

Otherwise, the implicitly-declared copy assignment operator will have the form `X& X::operator=(X&)`

19 A user-declared move assignment operator **X::operator=** is a non-static non-template member function of class X with exactly one parameter of type **X&&**, **const X&&**, **volatile X&&**, or **const volatile X&&**. [ Note: An overloaded assignment operator must be declared to have only one parameter; see 13.5.3. — end note ] [ Note: More than one form of move assignment operator may be declared for a class. — end note ]

20 If the definition of a class X does not explicitly declare a move assignment operator, one will be implicitly declared as defaulted if and only if

— X does not have a user-declared copy constructor,

— X does not have a user-declared move constructor,

— X does not have a user-declared copy assignment operator,

— X does not have a user-declared destructor, and

— the move assignment operator would not be implicitly defined as deleted.

[ Example: The class definition

```
struct S {
    int a;
    S& operator=(const S&) = default;   //[12.8/17], 这是一个 user-declared copy assignment operator
};
```

will not have a default move assignment operator implicitly declared because the copy assignment operator has been user-declared. The move assignment operator may be explicitly defaulted.

```
struct S {
    int a;
    S& operator=(const S&) = default;
    S& operator=(S&&) = default;
};
```

— end example ]

21 The implicitly-declared move assignment operator for a class X will have the form  `X& X::operator=(X&&);`

22 The implicitly-declared copy/move assignment operator for class X has the return type **X&**; it returns the object for which the assignment operator is invoked, that is, the object assigned to. An implicitly-declared copy/move assignment operator is an **inline public** member of its class.
23 A defaulted copy/move assignment operator for class X is defined as deleted if X has:

— a variant member with a non-trivial corresponding assignment operator and X is a union-like class, or

— a non-static data member of const non-class type (or array thereof), or

— a non-static data member of reference type, or

— a non-static data member of class type M (or array thereof) that cannot be copied/moved because overload resolution (13.3), as applied to M’s corresponding assignment operator, results in
an ambiguity or a function that is deleted or inaccessible from the defaulted assignment operator, or

— a direct or virtual base class B that cannot be copied/moved because overload resolution (13.3), as applied to B’s corresponding assignment operator, results in an ambiguity or a function that is deleted or inaccessible from the defaulted assignment operator, or

— for the move assignment operator, a non-static data member or direct base class with a type that does not have a move assignment operator and is not trivially copyable, or any direct or indirect virtual base class.

24 Because a copy/move assignment operator is implicitly declared for a class if not declared by the user, a base class copy/move assignment operator is always hidden by the corresponding assignment operator of a derived class (13.5.3). A *using-declaration* (7.3.3) that brings in(提供, 带来) from a base class an assignment operator with a parameter type that could be that of a copy/move assignment operator for the derived class is not considered an explicit declaration of such an operator and does not suppress the implicit declaration of the derived class operator; the operator introduced by the *using-declaration* is hidden by the implicitly-declared operator in the derived class.

使用using声明从基类中引入到派生类并且与派生类具有相同形参类型的copy/move赋值操作符不会被认为是派生类中显式声明的, 因此也不会抑制派生类中隐式声明的copy/move赋值操作符.

```
struct D;
struct B
{
	D& operator=(D& d)
	{
		 std::cout << "B::operator(D&)" << std::endl;
		 return const_cast<D&>(d);
    };
};

struct D : public B
{
 using B::operator =;
};
int main(int argc, char* argv[])
{
	D d1;
	const D d2;
	d1 = d2;		//使用隐式声明的版本;

	D d3;
	d3 = d1; //B::operator(D&)
		//D的作用域中存在两个重载的operator=:
		//一个是通过using声明引入的B::operator(D&)版本,
		//另一个是D隐式声明的版本D::operator(const D&),
		//而这个赋值将优先匹配B::operator(D&), 所以使用的赋值操作符是通过using引入的.
	return 0;
};
```

25 A copy/move assignment operator for class X is trivial if it is not user-provided and if

— class X has no virtual functions (10.3) and no virtual base classes (10.1), and

— the assignment operator selected to copy/move each direct base class subobject is trivial, and

— for each non-static data member of X that is of class type (or array thereof), the assignment operator selected to copy/move that member is trivial;

otherwise the copy/move assignment operator is non-trivial.

26 A copy/move assignment operator that is defaulted and not defined as deleted is *implicitly defined* when it is odr-used (3.2) (e.g., when it is selected by overload resolution to assign to an object of its class type) or when it is explicitly defaulted after its first declaration.

27 Before the defaulted copy/move assignment operator for a class is implicitly defined, all non-user-provided copy/move assignment operators for its direct base classes and its non-static data members shall have been implicitly defined. [Note: An implicitly-declared copy/move assignment operator has an exception- specification(15.4). —endnote]

28 The implicitly-defined copy/move assignment operator for a non-union class X performs memberwise(按成员) copy-/move assignment of its subobjects. The direct base classes of X are assigned first, in the order of their declaration in the *base-specifier-list*, and then the immediate non-static data members of X are assigned, in the order in which they were declared in the class definition. Let x be either the parameter of the function or, for the move operator, an xvalue referring to the parameter. Each subobject is assigned in the manner(以...的方式) appropriate to its type:

— if the subobject is of class type, as if by a call to **operator=** with the subobject as the object expression and the corresponding subobject of x as a single function argument (as if by explicit qualification; that is, ignoring any possible virtual overriding functions in more derived classes);

— if the subobject is an array, each element is assigned, in the manner appropriate to the element type;

— if the subobject is of scalar type, the built-in assignment operator is used.

It is unspecified whether subobjects representing virtual base classes are assigned more than once by the
implicitly-defined copy assignment operator.

```
struct V { };
struct A : virtual V { };
struct B : virtual V { };
struct C : B, A { };
```

It is unspecified whether the virtual base class subobject V is assigned twice by the implicitly-defined copy assignment operator for C. — end example ] [ Note: This does not apply to move assignment, as a defaulted move assignment operator is deleted if the class has virtual bases. — end note ]

29 The implicitly-defined copy assignment operator for a union X copies the object representation (3.9) of X.

30 A program is ill-formed if the copy/move constructor or the copy/move assignment operator for an object is implicitly odr-used and the special member function is not accessible (Clause 11). [ Note: Copying/moving one object into another using the copy/move constructor or the copy/move assignment operator does not change the layout or size of either object. — end note ]

### 12.9 Inheriting constructors

1 A *using-declaration* (7.3.3) that names a constructor implicitly declares a set of *inheriting constructors*. The *candidate set* of *inherited constructors* from the class X named in the *using-declaration* consists of actual constructors and notional constructors that result from the transformation of defaulted parameters as follows:

— all non-template constructors of X, and

— for each non-template constructor of X that has at least one parameter with a default argument, the set of constructors that results from omitting any ellipsis parameter specification and successively omitting parameters with a default argument from the end of the *parameter-type-list*, and

对于X的每个至少有一个形参带有默认参数的非模板构造函数, 除带有省略号的形参声明外, 依次从*parameter-type-list* 的后面开始省略带有默认实参的形参所构成的构造函数集合,

— all constructor templates of X, and

— for each constructor template of X that has at least one parameter with a default argument, the set of constructor templates that results from omitting any ellipsis parameter specification and successively omitting parameters with a default argument from the end of the parameter-type-list.

定义继承构造函数的候选集合

2 The *constructor characteristics* of a constructor or constructor template are the template parameter list (14.1), if any,

— the parameter-type-list (8.3.5),

— the exception-specification (15.4),

— absence or presence of **explicit** (12.3.1), and

— absence or presence of **constexpr** (7.1.5).

3 For each non-template constructor in the candidate set of inherited constructors other than a constructor having no parameters or a copy/move constructor having a single parameter, a constructor is implicitly declared with the same *constructor characteristics* unless there is a user-declared constructor with the same signature in the class where the *using-declaration* appears. Similarly, for each constructor template in the candidate set of inherited constructors, a constructor template is implicitly declared with the same constructor characteristics unless there is an equivalent user-declared constructor template (14.5.6.1) in the class where the using-declaration appears. [ Note: Default arguments are not inherited. — end note ]

4 A constructor so declared has the same access as the corresponding constructor in X. It is deleted if the corresponding constructor in X is deleted (8.4).

6 [ Example:

```
struct B1 {
    B1(int);
};
struct B2 {
    B2(int = 13, int = 42);
};
struct D1 : B1 {
    using B1::B1;
};
struct D2 : B2 {
    using B2::B2;
};
/*
The candidate set of inherited constructors in D1 for B1 is
— B1(const B1&)
— B1(B1&&)
— B1(int)

The set of constructors present in D1 is
— D1(), implicitly-declared default constructor, ill-formed if odr-used
— D1(const D1&), implicitly-declared copy constructor, not inherited
— D1(D1&&), implicitly-declared move constructor, not inherited
— D1(int), implicitly-declared inheriting constructor

The candidate set of inherited constructors in D2 for B2 is
— B2(const B2&)
— B2(B2&&)
— B2(int =  13, int = 42)
— B2(int = 13)
— B2()

The set of constructors present in D2 is
— D2(), implicitly-declared default constructor, not inherited
— D2(const D2&), implicitly-declared copy constructor, not inherited
— D2(D2&&), implicitly-declared move constructor, not inherited
— D2(int, int), implicitly-declared inheriting constructor
— D2(int), implicitly-declared inheriting constructor
*/

```

7 [Note: If two *using-declarations* declare inheriting constructors with the same signatures, the program is ill-formed (9.2, 13.1), because an implicitly-declared constructor introduced by the first using-declaration is not a user-declared constructor and thus does not preclude(阻止) another declaration of a constructor with the same signature by a subsequent *using-declaration*.

```
struct B1 {
    B1(int);
};
struct B2 {
    B2(int);
};
struct D1 : B1, B2 {
    using B1::B1;
    using B2::B2;
}; // ill-formed: attempts to declare D1(int) twice

struct D2 : B1, B2 {
    using B1::B1;
    using B2::B2;
    D2(int);    // OK: user declaration supersedes both implicit declarations
};
```

8 An inheriting constructor for a class is implicitly defined when it is odr-used (3.2) to create an object of its class type (1.8). An implicitly-defined inheriting constructor performs the set of initializations of the class that would be performed by a user-written **inline** constructor for that class with a *mem-initializer-list* whose only *mem-initializer* has a *mem-initializer-id* that names the base class denoted in the *nested-name-specifier* of the *using-declaration* and an *expression-list* as specified below, and where the *compound-statement* in its function body is empty (12.6.2). If that user-written constructor would be ill-formed, the program is ill-formed. Each *expression* in the *expression-list* is of the form **static_cast<T&&>(p)**, where p is the name of the corresponding constructor parameter and T is the declared type of p.

    *mem-initializer-list:
        mem-initializer ...opt
        mem-initializer , mem-initializer-list ...opt
    mem-initializer:
        mem-initializer-id ( expression-listopt )
        mem-initializer-id braced-init-list
    mem-initializer-id:
        class-or-decltype
        identifier*

9 [ Example:

```
struct B1 {
    B1(int) { }
};
struct B2 {
    B2(double) { }
};
struct D1 : B1 {
    using B1::B1;    // implicitly declares D1(int)
    int x;
};
void test() {
    D1 d(6);         // OK: d.x is not initialized
    D1 e;            // error: D1 has no default constructor
                     // D1有默认构造函数, 只是被定义为删除的. [12.1/5]
}
struct D2 : B2 {
    using B2::B2;    // OK: implicitly declares D2(double)
    B1 b;
};
D2 f(1.0);              // error: B1 has no default constructor

template< class T >
struct D : T {
    using T::T;         // declares all constructors from class T
    ~D() { std::clog << "Destroying wrapper" << std::endl; }
};
```

Class template D wraps any class and forwards all of its constructors, while writing a message to the standard log whenever an object of class D is destroyed. — end example ]

> 整个12.9在C++17中变动较大, 包括上面的例子也有变动.
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0136r1.html
GCC7.3之前在这里还有一个BUG
https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67054https://gcc.gnu.org/gcc-7/changes.html
>